'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const DEV = process.env.NODE_ENV !== "production";
const specialProperties = ["__proto__", "constructor", "prototype"];
const identity = (x) => x;
const is = (n) => n !== void 0 && n !== null;
const num = (n) => typeof n === "number" && !Number.isNaN(n);
const string = (n) => typeof n === "string" && n !== "";
const obj = (n) => typeof n === "object" && n !== null;
const func = (n) => typeof n === "function";
const negative = (n) => num(n) && n < 0;
const get = (from, path) => {
  const paths = String(path).split(".");
  const pathsLength = paths.length;
  let result = from;
  for (let i = 0; i < pathsLength; i += 1) {
    if (!is(result))
      return result;
    const path2 = paths[i];
    result = is(result[path2]) ? result[path2] : void 0;
  }
  return result;
};
const assign = (target, source) => {
  if (!is(source))
    return target;
  for (const key in source) {
    if (specialProperties.indexOf(key) !== -1) {
      continue;
    }
    target[key] = source[key];
  }
  return target;
};
const merge = (target, source) => {
  if (!is(source))
    return target;
  for (const key in source) {
    if (specialProperties.indexOf(key) !== -1) {
      continue;
    }
    if (obj(target[key])) {
      target[key] = merge(assign({}, target[key]), source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
};
const warn = (condition, message) => {
  if (DEV) {
    if (!condition && console.error) {
      console.error(message);
    }
  }
};
function cascade(value, arg) {
  if (typeof value === "function") {
    return cascade(value(arg), arg);
  }
  return value;
}
const getThemeValue = (props, path, initial = props.theme) => cascade(get(initial, path), props);
function omit(object, values) {
  const result = {};
  for (const key in object) {
    if (values.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function flattenStrings(array) {
  return array.reduce((flattenedArray, value) => {
    const lastIndex = flattenedArray.length - 1;
    const last = flattenedArray[lastIndex];
    if (typeof last === "string" && typeof value === "string") {
      flattenedArray[lastIndex] = last + value;
    } else {
      flattenedArray.push(value);
    }
    return flattenedArray;
  }, []);
}
function flattenDown(array, result) {
  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    if (Array.isArray(value)) {
      flattenDown(value, result);
    } else {
      result.push(value);
    }
  }
  return result;
}
function flatten(array) {
  return flattenDown(array, []);
}

exports.assign = assign;
exports.cascade = cascade;
exports.flatten = flatten;
exports.flattenStrings = flattenStrings;
exports.func = func;
exports.get = get;
exports.getThemeValue = getThemeValue;
exports.identity = identity;
exports.is = is;
exports.merge = merge;
exports.negative = negative;
exports.num = num;
exports.obj = obj;
exports.omit = omit;
exports.string = string;
exports.warn = warn;
//# sourceMappingURL=index.cjs.map
