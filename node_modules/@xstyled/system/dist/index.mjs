import { num, string, getThemeValue, negative, warn, merge, assign, func, is, obj, cascade } from '@xstyled/util';

var __pow = Math.pow;
const round = (value) => Math.round(value * __pow(10, 4)) / __pow(10, 4);
const unit = (unit2) => (value) => num(value) && value !== 0 ? `${value}${unit2}` : value;
const ms = unit("ms");
const px$1 = unit("px");
const deg = unit("deg");
const pxToRem = (value, { rootFontSize = 16 } = {}) => round(value / rootFontSize);
const remPx = (value, options) => {
  const num2 = Number(value);
  if (Number.isNaN(num2) || num2 === 0)
    return value;
  return `${pxToRem(num2, options)}rem`;
};
const rpx = (value, options) => {
  if (!string(value) || value.length < 4)
    return value;
  const unit2 = value.slice(-3);
  if (unit2 !== "rpx")
    return value;
  const n = Number(value.slice(0, value.length - 3));
  if (n === 0)
    return 0;
  return `${pxToRem(n, options)}rem`;
};
const percent = (n) => num(n) && n !== 0 && n >= -1 && n <= 1 ? `${round(n * 100)}%` : n;
const transformNegative = (_, { rawValue, variants, props }) => {
  if (string(rawValue)) {
    const neg = rawValue.startsWith("-");
    const abs = neg ? rawValue.substr(1) : rawValue;
    const varVal = getThemeValue(props, abs, variants);
    const value = string(varVal) || num(varVal) ? varVal : abs;
    return neg ? `-${value}` : value;
  }
  if (num(rawValue)) {
    const neg = negative(rawValue);
    const abs = Math.abs(rawValue);
    const varVal = variants ? variants[abs] : void 0;
    if (string(varVal))
      return neg ? `-${varVal}` : varVal;
    const value = num(varVal) ? varVal : abs;
    return neg ? value * -1 : value;
  }
  return void 0;
};

const mediaMinWidth = (value) => value ? `@media (min-width: ${value})` : null;
const mediaMaxWidth = (value) => value ? `@media (max-width: ${value})` : null;
const mediaBetweenWidth = (min, max) => min && max ? `@media (min-width: ${min}) and (max-width: ${max})` : null;
const getBreakpointMin = (screens, key) => {
  const value = screens[key];
  return value === 0 ? null : px$1(value);
};
const getBreakpointMax = (screens, key) => {
  const value = screens[key];
  return value === 0 ? null : px$1(value - 0.02);
};

var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
const getScreens = (props) => {
  return props.theme && props.theme.screens ? props.theme.screens : {};
};
const getStates = (props) => {
  return props.theme && props.theme.states ? props.theme.states : {};
};
const getVariants = (props) => {
  const screens = getScreens(props);
  const states = getStates(props);
  const medias = {};
  for (const value in screens) {
    medias[value] = mediaMinWidth(getBreakpointMin(screens, value));
  }
  const variants = __spreadValues$6(__spreadValues$6({}, medias), states);
  for (const [value, selector] of Object.entries(variants)) {
    if (selector && selector.startsWith("@")) {
      delete variants[value];
      variants[value] = selector;
    }
  }
  return variants;
};
const getCachedVariants = (props, cache) => {
  if (cache.has("_variants"))
    return cache.get("_variants");
  const states = getVariants(props);
  cache.set("_variants", states);
  return states;
};

const cacheSupported = typeof Map !== "undefined" && typeof WeakMap !== "undefined";
const caches = cacheSupported ? new WeakMap() : null;
const getThemeCache = (theme) => {
  if (caches === null)
    return null;
  if (caches.has(theme))
    return caches.get(theme) || null;
  const cache = {};
  caches.set(theme, cache);
  return cache;
};
const noopCache = {
  has: () => false,
  set: () => void 0,
  get: () => void 0
};
const getCache = (theme, namespace) => {
  if (!theme)
    return noopCache;
  const cache = getThemeCache(theme);
  if (!cache || !theme)
    return noopCache;
  cache[namespace] = cache[namespace] || new Map();
  return cache[namespace];
};

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj2, key, value) => key in obj2 ? __defProp$5(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
let themeGetterId = 0;
const SPLITTERS = {
  shorthand: [/\s+/, " "],
  multiple: [/\s*,\s*/, ","]
};
const splitValue = (splitter, transform) => (value) => value.split(splitter[0]).map(transform).join(splitter[1]);
const themeGetter = ({
  name,
  transform: defaultTransform,
  key,
  compose: compose2,
  shorthand,
  multiple
}) => {
  const id = themeGetterId++;
  const getter = (value, defaultValue) => (props) => {
    let res = value;
    if (!string(value) && !num(value) && value !== true) {
      return res;
    }
    const cacheKey = `${typeof value}-${value}-${defaultValue}`;
    const cache = getCache(props.theme, `__themeGetter${id}`);
    if (cache.has(cacheKey))
      return cache.get(cacheKey);
    const getValue = (value2) => {
      const localDefaultValue = is(defaultValue) ? defaultValue : value2;
      let res2 = value2;
      const variants = is(key) ? getThemeValue(props, key) : null;
      if (is(variants)) {
        const path = value2 === true ? "default" : string(value2) || num(value2) ? value2 : null;
        if (is(path)) {
          const fromTheme = getThemeValue(props, path, variants);
          res2 = Array.isArray(fromTheme) ? fromTheme.join(",") : fromTheme;
        }
      }
      let rawValue = value2;
      if (!is(res2)) {
        rawValue = localDefaultValue;
        res2 = localDefaultValue;
      }
      const transform = (name && props.theme && props.theme.transformers ? props.theme.transformers[name] : null) || defaultTransform;
      if (transform) {
        res2 = transform(res2, {
          rawValue,
          variants,
          props
        });
      }
      return compose2 ? compose2(res2)(props) : res2;
    };
    if ((shorthand || multiple) && string(value)) {
      let transform = getValue;
      if (shorthand)
        transform = splitValue(SPLITTERS.shorthand, transform);
      if (multiple)
        transform = splitValue(SPLITTERS.multiple, transform);
      res = transform(value);
    } else {
      res = getValue(value);
    }
    cache.set(cacheKey, res);
    return res;
  };
  getter.meta = { name, transform: defaultTransform };
  return getter;
};
const createStyleGenerator = ({
  getStyle,
  props,
  cssGetters = {},
  generators
}) => {
  const generator = getStyle;
  generator.meta = {
    props,
    cssGetters,
    getStyle: generator,
    generators
  };
  generator.apply = (values) => ({ theme }) => generator(__spreadValues$5({ theme }, values));
  return generator;
};
const reduceVariants = (props, values, getStyle) => {
  const cache = getCache(props.theme, "__variants");
  const variants = getCachedVariants(props, cache);
  let styles = {};
  for (const value in values) {
    const style2 = getStyle(values[value]);
    if (style2 === null)
      continue;
    const state = value in variants ? variants[value] : value;
    if (state === void 0)
      continue;
    if (state === null) {
      styles = merge(styles, style2);
    } else {
      styles[state] = styles[state] ? assign(styles[state], style2) : style2;
    }
  }
  return styles;
};
const getStyleFactory = (prop, mixin, themeGet) => {
  return (props) => {
    const fromValue = (value2) => {
      if (!is(value2))
        return null;
      if (obj(value2))
        return reduceVariants(props, value2, fromValue);
      return cascade(mixin(themeGet ? themeGet(value2)(props) : value2), props);
    };
    const value = props[prop];
    if (!is(value))
      return null;
    const cache = getCache(props.theme, prop);
    if (cache.has(value))
      return cache.get(value);
    const style2 = fromValue(props[prop]);
    cache.set(value, style2);
    return style2;
  };
};
const indexGeneratorsByProp = (generators) => {
  const index = {};
  for (let i = 0; i < generators.length; i++) {
    const style2 = generators[i];
    if (style2 && style2.meta) {
      for (let j = 0; j < style2.meta.props.length; j++) {
        const prop = style2.meta.props[j];
        index[prop] = style2;
      }
    }
  }
  return index;
};
const sortStyles = (styles, variants) => {
  for (const key in variants) {
    const variant = variants[key];
    const style2 = styles[variant];
    if (!style2)
      continue;
    delete styles[variant];
    styles[variant] = style2;
  }
  return styles;
};
function compose(...generators) {
  let flatGenerators = [];
  generators.forEach((gen) => {
    warn(Boolean(gen), `Undefined generator in "compose" method`);
    if (!gen)
      return;
    if (gen.meta.generators) {
      flatGenerators = [...flatGenerators, ...gen.meta.generators];
    } else {
      flatGenerators.push(gen);
    }
  });
  const generatorsByProp = indexGeneratorsByProp(flatGenerators);
  const getStyle = (props2, sort = true) => {
    const styles = {};
    let merged;
    for (const key in props2) {
      const generator = generatorsByProp[key];
      if (generator) {
        const style2 = generator.meta.getStyle(props2, false);
        merge(styles, style2);
        merged = true;
      }
    }
    if (!merged || !sort)
      return styles;
    const medias = getCachedVariants(props2, getCache(props2.theme, "__states"));
    return sortStyles(styles, medias);
  };
  const props = [];
  const cssGetters = {};
  for (let i = 0; i < flatGenerators.length; i++) {
    const generator = flatGenerators[i];
    props.push(...generator.meta.props);
    Object.assign(cssGetters, generator.meta.cssGetters);
  }
  return createStyleGenerator({ getStyle, props, cssGetters, generators });
}
const getMixinFromCSSProperties = (properties) => (value) => {
  if (string(properties))
    return { [properties]: value };
  const style2 = {};
  for (const key in properties) {
    style2[properties[key]] = value;
  }
  return style2;
};
const getMixinFromCSSOption = (css) => {
  if (func(css))
    return css;
  return getMixinFromCSSProperties(css);
};
const dasherize = (key) => key.replace(/[A-Z]/g, "-$&").toLowerCase();
const style = ({
  prop,
  css,
  themeGet,
  key,
  transform,
  cssProps: cssPropsOption
}) => {
  const getter = themeGet || (key || transform ? themeGetter({ key, transform }) : void 0);
  const cssProps = cssPropsOption || (string(css) ? [css] : Array.isArray(css) ? css : string(prop) ? [prop] : Array.isArray(prop) ? prop : []);
  if (Array.isArray(prop)) {
    const mixin2 = css ? getMixinFromCSSOption(css) : css;
    const generators2 = prop.map((prop2) => style({ prop: prop2, css: mixin2, cssProps, themeGet: getter }));
    return compose(...generators2);
  }
  const props = [prop];
  const mixin = getMixinFromCSSOption(css || props);
  const generators = [];
  const getStyle = getStyleFactory(prop, mixin, getter);
  const cssGetters = getter ? cssProps.reduce((getters, cssProp) => {
    getters[dasherize(cssProp)] = getter;
    return getters;
  }, {}) : {};
  const generator = createStyleGenerator({ getStyle, props, cssGetters });
  generators.push(generator);
  return compose(...generators);
};

const getPx = themeGetter({
  name: "px",
  transform: (value, { props }) => {
    var _a, _b, _c;
    const rootFontSize = (_c = (_b = (_a = props == null ? void 0 : props.theme) == null ? void 0 : _a.settings) == null ? void 0 : _b.rootFontSize) != null ? _c : void 0;
    const num = Number(value);
    return px$1(rpx(Number.isNaN(num) ? value : num, { rootFontSize }));
  }
});
const getDuration = themeGetter({
  name: "duration",
  key: "durations",
  transform: (value) => {
    const num = Number(value);
    return ms(Number.isNaN(num) ? value : num);
  }
});
const getAngle = themeGetter({
  name: "angle",
  transform: (value) => {
    const num = Number(value);
    return deg(Number.isNaN(num) ? value : num);
  }
});
const getPercent = themeGetter({
  name: "percent",
  compose: getPx,
  transform: percent
});

const getTransition = themeGetter({
  name: "transition",
  key: "transitions"
});
const getTransitionProperty = themeGetter({
  name: "transitionProperty",
  key: "transitionProperties"
});
const getTimingFunction = themeGetter({
  name: "timingFunction",
  key: "timingFunctions"
});
const transition = style({
  prop: "transition",
  themeGet: getTransition
});
const transitionProperty = style({
  prop: "transitionProperty",
  themeGet: getTransitionProperty
});
const transitionDuration = style({
  prop: "transitionDuration",
  themeGet: getDuration
});
const transitionTimingFunction = style({
  prop: "transitionTimingFunction",
  themeGet: getTimingFunction
});
const transitionDelay = style({
  prop: "transitionDelay",
  themeGet: getDuration
});
const transitions$1 = compose(transition, transitionProperty, transitionDuration, transitionTimingFunction, transitionDelay);

const getAnimation = themeGetter({
  name: "animation",
  key: "animations"
});
const animation = style({
  prop: "animation",
  themeGet: getAnimation
});
const animationDuration = style({
  prop: "animationDuration",
  themeGet: getDuration
});
const animationTimingFunction = style({
  prop: "animationTimingFunction",
  themeGet: getTimingFunction
});
const animations = compose(animation, animationDuration, animationTimingFunction);

const getColor = themeGetter({
  name: "color",
  key: "colors"
});

const gradientBackgrounds = {
  "gradient-to-t": "linear-gradient(to top, var(--x-gradient-stops))",
  "gradient-to-tr": "linear-gradient(to top right, var(--x-gradient-stops))",
  "gradient-to-r": "linear-gradient(to right, var(--x-gradient-stops))",
  "gradient-to-br": "linear-gradient(to bottom right, var(--x-gradient-stops))",
  "gradient-to-b": "linear-gradient(to bottom, var(--x-gradient-stops))",
  "gradient-to-bl": "linear-gradient(to bottom left, var(--x-gradient-stops))",
  "gradient-to-l": "linear-gradient(to left, var(--x-gradient-stops))",
  "gradient-to-tl": "linear-gradient(to top left, var(--x-gradient-stops))"
};
const background = style({
  prop: "background",
  css: (value) => ({
    background: gradientBackgrounds[value] || value
  })
});
const backgroundColor = style({
  prop: ["backgroundColor", "bg"],
  css: "backgroundColor",
  themeGet: getColor
});
const backgroundImage = style({
  prop: "backgroundImage",
  css: (value) => ({
    backgroundImage: gradientBackgrounds[value] || value
  })
});
const backgroundSize = style({
  prop: "backgroundSize"
});
const backgroundPosition = style({
  prop: "backgroundPosition"
});
const backgroundRepeat = style({
  prop: "backgroundRepeat"
});
const backgroundAttachment = style({
  prop: "backgroundAttachment"
});
const backgroundClip = style({
  prop: "backgroundClip",
  css: ["backgroundClip", "-webkitBackgroundClip"]
});
const gradientFrom = style({
  prop: "gradientFrom",
  themeGet: getColor,
  css: (value) => {
    return {
      "--x-gradient-from": value,
      "--x-gradient-stops": "var(--x-gradient-from), var(--x-gradient-to, transparent)"
    };
  }
});
const gradientVia = style({
  prop: "gradientVia",
  themeGet: getColor,
  css: (value) => ({
    "--x-gradient-stops": `var(--x-gradient-from), ${value}, var(--x-gradient-to, transparent)`
  })
});
const gradientTo = style({
  prop: "gradientTo",
  themeGet: getColor,
  css: "--x-gradient-to"
});
const backgrounds = compose(background, backgroundColor, backgroundImage, backgroundSize, backgroundPosition, backgroundRepeat, backgroundAttachment, backgroundClip, gradientFrom, gradientVia, gradientTo);

const getBorder = themeGetter({
  name: "border",
  key: "borders",
  transform: (value) => {
    const num = Number(value);
    return num > 0 ? `${px$1(num)} solid` : value;
  }
});
const getBorderWidth = themeGetter({
  name: "borderWidth",
  key: "borderWidths",
  compose: getPx,
  shorthand: true
});
const getBorderColor = themeGetter({
  name: "borderColor",
  compose: getColor,
  shorthand: true
});
const getBorderStyle = themeGetter({
  name: "borderStyle",
  key: "borderStyles"
});
const border = style({
  prop: "border",
  themeGet: getBorder
});
const borderTop = style({
  prop: "borderTop",
  themeGet: getBorder
});
const borderRight = style({
  prop: "borderRight",
  themeGet: getBorder
});
const borderBottom = style({
  prop: "borderBottom",
  themeGet: getBorder
});
const borderLeft = style({
  prop: "borderLeft",
  themeGet: getBorder
});
const borderColor = style({
  prop: "borderColor",
  themeGet: getBorderColor
});
const borderTopColor = style({
  prop: "borderTopColor",
  themeGet: getColor
});
const borderRightColor = style({
  prop: "borderRightColor",
  themeGet: getColor
});
const borderBottomColor = style({
  prop: "borderBottomColor",
  themeGet: getColor
});
const borderLeftColor = style({
  prop: "borderLeftColor",
  themeGet: getColor
});
const borderWidth = style({
  prop: "borderWidth",
  themeGet: getBorderWidth
});
const borderTopWidth = style({
  prop: "borderTopWidth",
  themeGet: getBorderWidth
});
const borderRightWidth = style({
  prop: "borderRightWidth",
  themeGet: getBorderWidth
});
const borderBottomWidth = style({
  prop: "borderBottomWidth",
  themeGet: getBorderWidth
});
const borderLeftWidth = style({
  prop: "borderLeftWidth",
  themeGet: getBorderWidth
});
const borderStyle = style({
  prop: "borderStyle",
  themeGet: getBorderStyle,
  cssProps: [
    "borderStyle",
    "borderTopStyle",
    "borderRightStyle",
    "borderBottomStyle",
    "borderLeftStyle"
  ]
});
const borderTopStyle = style({
  prop: "borderTopStyle",
  themeGet: getBorderStyle
});
const borderRightStyle = style({
  prop: "borderRightStyle",
  themeGet: getBorderStyle
});
const borderBottomStyle = style({
  prop: "borderBottomStyle",
  themeGet: getBorderStyle
});
const borderLeftStyle = style({
  prop: "borderLeftStyle",
  themeGet: getBorderStyle
});
const outline = style({
  prop: "outline",
  themeGet: getBorder
});
const outlineColor = style({
  prop: "outlineColor",
  themeGet: getColor
});
const outlineWidth = style({
  prop: "outlineWidth",
  themeGet: getBorderWidth
});
const outlineStyle = style({
  prop: "outlineStyle",
  themeGet: getBorderStyle
});
const outlineOffset = style({
  prop: "outlineOffset",
  themeGet: getBorderWidth
});
const getRadius = themeGetter({
  name: "radius",
  key: "radii",
  compose: getPx,
  shorthand: true
});
const borderRadius = style({
  prop: "borderRadius",
  themeGet: getRadius,
  cssProps: [
    "borderRadius",
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomRightRadius",
    "borderBottomLeftRadius"
  ]
});
const divideSelector = `& > :not([hidden]) ~ :not([hidden])`;
const divideY = style({
  prop: "divideY",
  themeGet: getBorderWidth,
  css: (value) => {
    const v = value === true ? 1 : value;
    return {
      [divideSelector]: {
        "--x-divide-y-reverse": 0,
        borderTopWidth: `calc(${v} * calc(1 - var(--x-divide-y-reverse)))`,
        borderBottomWidth: `calc(${v} * var(--x-divide-y-reverse))`
      }
    };
  }
});
const divideX = style({
  prop: "divideX",
  themeGet: getBorderWidth,
  css: (value) => {
    const v = value === true ? 1 : value;
    return {
      [divideSelector]: {
        "--x-divide-x-reverse": 0,
        borderRightWidth: `calc(${v} * var(--x-divide-x-reverse))`,
        borderLeftWidth: `calc(${v} * calc(1 - var(--x-divide-x-reverse)))`
      }
    };
  }
});
const divideXReverse = style({
  prop: "divideXReverse",
  css: () => ({
    [divideSelector]: {
      "--x-divide-x-reverse": "1"
    }
  })
});
const divideYReverse = style({
  prop: "divideYReverse",
  css: () => ({
    [divideSelector]: {
      "--x-divide-y-reverse": "1"
    }
  })
});
const divideColor = style({
  prop: "divideColor",
  themeGet: getColor,
  css: (value) => ({
    [divideSelector]: {
      borderColor: value
    }
  })
});
const divideStyle = style({
  prop: "divideStyle",
  themeGet: getBorderStyle,
  css: (value) => ({
    [divideSelector]: {
      borderStyle: value
    }
  })
});
const getRingWidth = themeGetter({
  name: "ringWidth",
  key: "ringWidths",
  compose: getPx
});
const ring = style({
  prop: "ring",
  themeGet: getRingWidth,
  css: (value) => ({
    "--x-ring-shadow": `var(--x-ring-inset, /*!*/ /*!*/) 0 0 0 ${value} var(--x-ring-color)`,
    boxShadow: "var(--x-ring-shadow, 0 0 #0000), var(--x-shadow, 0 0 #0000)"
  })
});
const ringInset = style({
  prop: "ringInset",
  css: () => ({ "--x-ring-inset": "inset" })
});
const ringColor = style({
  prop: "ringColor",
  themeGet: getColor,
  css: (value) => ({ "--x-ring-color": value })
});
const borders = compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderWidth, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, borderStyle, borderTopStyle, borderRightStyle, borderBottomStyle, borderLeftStyle, borderRadius, outline, outlineColor, outlineWidth, outlineStyle, outlineOffset, divideX, divideY, divideXReverse, divideYReverse, divideColor, divideStyle, ring, ringInset, ringColor);

const getShadow = themeGetter({
  name: "shadow",
  key: "shadows",
  multiple: true
});
const opacity = style({
  prop: "opacity"
});
const boxShadow = style({
  prop: "boxShadow",
  themeGet: getShadow,
  css: (value) => ({
    "--x-shadow": value,
    boxShadow: "var(--x-ring-shadow, 0 0 #0000), var(--x-shadow)"
  })
});
const textShadow = style({
  prop: "textShadow",
  themeGet: getShadow
});
const effects = compose(opacity, boxShadow, textShadow);

var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj2, key, value) => key in obj2 ? __defProp$4(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
const row = style({
  prop: "row",
  css: () => ({
    boxSizing: "border-box",
    flexGrow: 1,
    flexWrap: "wrap",
    display: "flex"
  })
});
const getColStyle = (props, size) => {
  if (!is(size))
    return null;
  if (size === true) {
    return {
      flexBasis: 0,
      flexGrow: 1,
      maxWidth: "100%"
    };
  }
  if (size === "auto") {
    return {
      flex: `0 0 auto`,
      maxWidth: "none",
      width: "auto"
    };
  }
  const sizeWidth = getPercent(size)(props);
  return {
    flex: `0 0 ${sizeWidth}`,
    maxWidth: sizeWidth
  };
};
const col = createStyleGenerator({
  getStyle: (props) => {
    const value = props.col;
    const common = {
      boxSizing: "border-box",
      flexBasis: 0,
      flexGrow: 1,
      maxWidth: "100%"
    };
    if (obj(value)) {
      const breakpointsStyle = reduceVariants(props, value, (v) => getColStyle(props, v));
      return __spreadValues$4(__spreadValues$4({}, common), breakpointsStyle);
    }
    return __spreadValues$4(__spreadValues$4({}, common), getColStyle(props, value));
  },
  props: ["col"]
});
const flexboxGrids = compose(row, col);

var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj2, key, value) => key in obj2 ? __defProp$3(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
const display = style({
  prop: "display"
});
const float = style({
  prop: "float"
});
const boxSizing = style({
  prop: "boxSizing"
});
const container = createStyleGenerator({
  getStyle: (props) => {
    if (!props.container)
      return null;
    const breakpoints = getScreens(props);
    let styles = reduceVariants(props, breakpoints, (v) => v !== 0 ? { maxWidth: v } : {});
    if (obj(props.container)) {
      styles = reduceVariants(props, props.container, () => styles);
    }
    return __spreadValues$3({
      width: "100%"
    }, styles);
  },
  props: ["container"]
});
const overflow = style({
  prop: "overflow"
});
const overflowX = style({
  prop: "overflowX"
});
const overflowY = style({
  prop: "overflowY"
});
const getZIndex = themeGetter({
  name: "zIndex",
  key: "zIndices"
});
const zIndex = style({
  prop: "zIndex",
  themeGet: getZIndex
});
const position = style({
  prop: "position"
});
const getInset = themeGetter({
  name: "inset",
  key: "inset",
  compose: getPx,
  transform: transformNegative
});
const top = style({
  prop: "top",
  themeGet: getInset
});
const right = style({
  prop: "right",
  themeGet: getInset
});
const bottom = style({
  prop: "bottom",
  themeGet: getInset
});
const left = style({
  prop: "left",
  themeGet: getInset
});
const visibility = style({
  prop: "visibility"
});
const overscrollBehavior = style({
  prop: "overscrollBehavior"
});
const objectFit = style({
  prop: "objectFit"
});
const layout = compose(boxSizing, display, float, container, overflow, overflowX, overflowY, position, zIndex, top, right, bottom, left, visibility, overscrollBehavior, objectFit);

const alignItems = style({
  prop: "alignItems"
});
const alignContent = style({
  prop: "alignContent"
});
const justifyContent = style({
  prop: "justifyContent"
});
const justifyItems = style({
  prop: "justifyItems"
});
const flexWrap = style({
  prop: "flexWrap"
});
const flexGrow = style({
  prop: "flexGrow"
});
const flexShrink = style({
  prop: "flexShrink"
});
const flexBasis = style({
  prop: "flexBasis",
  themeGet: getPercent
});
const flexDirection = style({
  prop: "flexDirection"
});
const flex = style({
  prop: "flex"
});
const justifySelf = style({
  prop: "justifySelf"
});
const alignSelf = style({
  prop: "alignSelf"
});
const order = style({
  prop: "order"
});
const flexboxes = compose(display, alignItems, alignContent, justifyContent, justifyItems, flexWrap, flexBasis, flexShrink, flexGrow, flexDirection, flex, justifySelf, alignSelf, order);

const getSpace = themeGetter({
  name: "space",
  key: "space",
  compose: getPx,
  shorthand: true,
  transform: transformNegative
});
const margin = style({
  prop: ["margin", "m"],
  themeGet: getSpace,
  css: "margin"
});
const marginTop = style({
  prop: ["marginTop", "mt"],
  themeGet: getSpace,
  css: "marginTop"
});
const marginRight = style({
  prop: ["marginRight", "mr"],
  themeGet: getSpace,
  css: "marginRight"
});
const marginBottom = style({
  prop: ["marginBottom", "mb"],
  themeGet: getSpace,
  css: "marginBottom"
});
const marginLeft = style({
  prop: ["marginLeft", "ml"],
  themeGet: getSpace,
  css: "marginLeft"
});
const mx = style({
  prop: "mx",
  themeGet: getSpace,
  css: ["marginRight", "marginLeft"]
});
const my = style({
  prop: "my",
  themeGet: getSpace,
  css: ["marginTop", "marginBottom"]
});
const padding = style({
  prop: ["padding", "p"],
  themeGet: getSpace,
  css: "padding"
});
const paddingTop = style({
  prop: ["paddingTop", "pt"],
  themeGet: getSpace,
  css: "paddingTop"
});
const paddingRight = style({
  prop: ["paddingRight", "pr"],
  themeGet: getSpace,
  css: "paddingRight"
});
const paddingBottom = style({
  prop: ["paddingBottom", "pb"],
  themeGet: getSpace,
  css: "paddingBottom"
});
const paddingLeft = style({
  prop: ["paddingLeft", "pl"],
  themeGet: getSpace,
  css: "paddingLeft"
});
const px = style({
  prop: "px",
  themeGet: getSpace,
  css: ["paddingRight", "paddingLeft"]
});
const py = style({
  prop: "py",
  themeGet: getSpace,
  css: ["paddingTop", "paddingBottom"]
});
const spaceY = style({
  prop: "spaceY",
  themeGet: getSpace,
  css: (value) => ({
    "& > :not([hidden]) ~ :not([hidden])": {
      "--x-space-y-reverse": 0,
      marginTop: `calc(${value} * calc(1 - var(--x-space-y-reverse)))`,
      marginBottom: `calc(${value} * var(--x-space-y-reverse))`
    }
  })
});
const spaceX = style({
  prop: "spaceX",
  themeGet: getSpace,
  css: (value) => ({
    "& > :not([hidden]) ~ :not([hidden])": {
      "--x-space-x-reverse": 0,
      marginRight: `calc(${value} * var(--x-space-x-reverse))`,
      marginLeft: `calc(${value} * calc(1 - var(--x-space-x-reverse)))`
    }
  })
});
const spaceXReverse = style({
  prop: "spaceXReverse",
  css: () => ({
    "& > :not([hidden]) ~ :not([hidden])": {
      "--x-space-x-reverse": "1"
    }
  })
});
const spaceYReverse = style({
  prop: "spaceYReverse",
  css: () => ({
    "& > :not([hidden]) ~ :not([hidden])": {
      "--x-space-y-reverse": "1"
    }
  })
});
const space$1 = compose(margin, marginTop, marginRight, marginBottom, marginLeft, mx, my, padding, paddingTop, paddingRight, paddingBottom, paddingLeft, px, py, spaceX, spaceY, spaceXReverse, spaceYReverse);

const gap = style({
  prop: "gap",
  themeGet: getSpace
});
const columnGap = style({
  prop: "columnGap",
  themeGet: getSpace
});
const rowGap = style({
  prop: "rowGap",
  themeGet: getSpace
});
const gridColumn = style({
  prop: "gridColumn"
});
const gridRow = style({
  prop: "gridRow"
});
const gridAutoFlow = style({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style({
  prop: "gridAutoColumns"
});
const gridAutoRows = style({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style({
  prop: "gridTemplateColumns",
  key: "gridTemplateColumns"
});
const gridTemplateRows = style({
  prop: "gridTemplateRows",
  key: "gridTemplateRows"
});
const gridTemplateAreas = style({
  prop: "gridTemplateAreas"
});
const gridArea = style({
  prop: "gridArea"
});
const grids = compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

const appearance = style({
  prop: "appearance"
});
const cursor = style({
  prop: "cursor"
});
const pointerEvents = style({
  prop: "pointerEvents"
});
const resize = style({
  prop: "resize"
});
const userSelect = style({
  prop: "userSelect"
});
const interactivity = compose(appearance, cursor, pointerEvents, resize, userSelect);

const getSize = themeGetter({
  name: "size",
  key: "sizes",
  compose: getPercent
});
const width = style({
  prop: "w",
  themeGet: getSize,
  css: "width"
});
const height = style({
  prop: "h",
  themeGet: getSize,
  css: "height"
});
const maxWidth = style({
  prop: ["maxWidth", "maxW"],
  themeGet: getSize,
  css: "maxWidth"
});
const maxHeight = style({
  prop: ["maxHeight", "maxH"],
  themeGet: getSize,
  css: "maxHeight"
});
const minWidth = style({
  prop: ["minWidth", "minW"],
  themeGet: getSize,
  css: "minWidth"
});
const minHeight = style({
  prop: ["minHeight", "minH"],
  themeGet: getSize,
  css: "minHeight"
});
const maskSize = style({
  prop: "maskSize",
  themeGet: themeGetter({
    name: "size",
    key: "sizes",
    compose: getPercent,
    multiple: true,
    shorthand: true
  })
});
const sizing = compose(width, height, maxWidth, maxHeight, minWidth, minHeight, maskSize);

const fill = style({
  prop: "fill",
  themeGet: getColor
});
const stroke = style({
  prop: "stroke",
  themeGet: getColor
});
const svg = compose(fill, stroke);

const borderCollapse = style({
  prop: "borderCollapse"
});
const tableLayout = style({
  prop: "tableLayout"
});
const tables = compose(borderCollapse, tableLayout);

const getTransform = themeGetter({
  name: "transform",
  key: "transforms"
});
const transform = style({
  prop: "transform",
  themeGet: getTransform,
  css: (value) => {
    if (value === true) {
      return {
        "--x-translate-x": 0,
        "--x-translate-y": 0,
        "--x-rotate": 0,
        "--x-skew-x": 0,
        "--x-skew-y": 0,
        "--x-scale-x": "1",
        "--x-scale-y": "1",
        transform: "translate3d(var(--x-translate-x), var(--x-translate-y), 0) rotate(var(--x-rotate)) skewX(var(--x-skew-x)) skewY(var(--x-skew-y)) scaleX(var(--x-scale-x)) scaleY(var(--x-scale-y))"
      };
    }
    return { transform: value };
  }
});
const transformOrigin = style({
  prop: "transformOrigin"
});
const translateX = style({
  prop: "translateX",
  themeGet: getSpace,
  css: "--x-translate-x"
});
const translateY = style({
  prop: "translateY",
  themeGet: getSpace,
  css: "--x-translate-y"
});
const rotate = style({
  prop: "rotate",
  themeGet: getAngle,
  css: "--x-rotate"
});
const skewX = style({
  prop: "skewX",
  themeGet: getAngle,
  css: "--x-skew-x"
});
const skewY = style({
  prop: "skewY",
  themeGet: getAngle,
  css: "--x-skew-y"
});
const scale = style({
  prop: "scale",
  transform: (v) => String(v),
  css: ["--x-scale-x", "--x-scale-y"]
});
const scaleX = style({
  prop: "scaleX",
  transform: (v) => String(v),
  css: "--x-scale-x"
});
const scaleY = style({
  prop: "scaleY",
  transform: (v) => String(v),
  css: "--x-scale-y"
});
const transforms = compose(transform, transformOrigin, translateX, translateY, rotate, skewX, skewY, scale, scaleX, scaleY);

var __defProp$2 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const getFont = themeGetter({ name: "font", key: "fonts" });
const getLineHeight = themeGetter({
  name: "lineHeight",
  key: "lineHeights",
  transform: (value, { props }) => {
    var _a, _b, _c;
    const rootFontSize = (_c = (_b = (_a = props == null ? void 0 : props.theme) == null ? void 0 : _a.settings) == null ? void 0 : _b.rootFontSize) != null ? _c : void 0;
    return rpx(value, { rootFontSize });
  }
});
const getFontWeight = themeGetter({
  name: "fontWeight",
  key: "fontWeights"
});
const getLetterSpacing = themeGetter({
  name: "letterSpacing",
  key: "letterSpacings",
  compose: getPx
});
const getFontSize = themeGetter({
  name: "fontSize",
  key: "fontSizes",
  compose: getPx
});
const fontFamily = style({
  prop: "fontFamily",
  themeGet: getFont
});
const fontSize = style({
  prop: "fontSize",
  themeGet: getFontSize
});
const lineHeight = style({
  prop: "lineHeight",
  themeGet: getLineHeight
});
const fontWeight = style({
  prop: "fontWeight",
  themeGet: getFontWeight
});
const fontStyle = style({
  prop: "fontStyle"
});
const letterSpacing = style({
  prop: "letterSpacing",
  themeGet: getLetterSpacing
});
const color = style({
  prop: "color",
  themeGet: getColor
});
const textTransform = style({
  prop: "textTransform"
});
const textDecoration = style({
  prop: "textDecoration"
});
const textAlign = style({
  prop: "textAlign"
});
const verticalAlign = style({
  prop: "verticalAlign"
});
const whiteSpace = style({
  prop: "whiteSpace"
});
const textOverflow = style({
  prop: "textOverflow"
});
const listStyleType = style({
  prop: "listStyleType"
});
const listStylePosition = style({
  prop: "listStylePosition"
});
const all = compose(space$1, fontFamily, fontSize, fontStyle, lineHeight, fontWeight, textAlign, letterSpacing, color, textTransform, textDecoration, verticalAlign, whiteSpace, textOverflow, listStyleType, listStylePosition);
const text = style({
  prop: "text",
  key: "texts",
  css: (value) => ({ theme }) => all(__spreadProps$1(__spreadValues$2({}, value), { theme }))
});
const typography = compose(all, text);

const system = compose(animations, backgrounds, borders, effects, flexboxGrids, flexboxes, grids, interactivity, layout, sizing, space$1, svg, tables, transforms, transitions$1, typography);

const th = (path, defaultValue) => (props) => {
  const value = getThemeValue(props, path);
  if (is(value))
    return value;
  if (is(defaultValue))
    return defaultValue;
  return path;
};
[
  getAngle,
  getAnimation,
  getBorder,
  getBorderColor,
  getBorderStyle,
  getBorderWidth,
  getColor,
  getDuration,
  getFont,
  getFontSize,
  getFontWeight,
  getInset,
  getLetterSpacing,
  getLineHeight,
  getPercent,
  getPx,
  getRadius,
  getRingWidth,
  getShadow,
  getSize,
  getSpace,
  getTimingFunction,
  getTransform,
  getTransition,
  getTransitionProperty,
  getZIndex
].forEach((themeGetter) => {
  th[themeGetter.meta.name] = themeGetter;
});

const up = (key, rules) => (props) => {
  const screens = getScreens(props);
  const value = getBreakpointMin(screens, key);
  if (value === null)
    return rules;
  return [`${mediaMinWidth(value)} {`, rules, "}"];
};
const down = (key, rules) => (props) => {
  const screens = getScreens(props);
  const value = getBreakpointMax(screens, key);
  if (value === null)
    return null;
  return [`${mediaMaxWidth(value)} {`, rules, "}"];
};
const between = (lower, upper, rules) => (props) => {
  const screens = getScreens(props);
  const min = getBreakpointMin(screens, lower);
  const max = getBreakpointMax(screens, upper);
  if (max === null)
    return up(lower, rules)(props);
  if (min === null)
    return down(upper, rules)(props);
  return [`${mediaBetweenWidth(min, max)} {`, rules, "}"];
};
const breakpoints = (values) => (props) => {
  const allRules = [];
  const keys = Object.keys(values);
  const keysLength = keys.length;
  for (let i = 0; i < keysLength; i++) {
    const key = keys[i];
    const rules = values[key];
    const result = up(key, rules)(props);
    if (Array.isArray(result)) {
      result.forEach((v) => allRules.push(v));
    } else {
      allRules.push(result);
    }
  }
  return allRules;
};

const rpxTransformers = {
  px: (value) => remPx(rpx(value)),
  border: (value) => num(value) && value > 0 ? `${remPx(value)} solid` : value
};

var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
const defaultAlphaVariants = [
  0,
  5,
  10,
  20,
  25,
  30,
  40,
  50,
  60,
  70,
  75,
  80,
  90,
  95,
  100
];
const generateHexAlphaVariants = (colors, variants = defaultAlphaVariants) => {
  const transform = (value, variant) => `${value}${Math.round(variant / 100 * 255).toString(16)}`;
  const alphaColors = Object.keys(colors).reduce((obj, key) => {
    variants.forEach((variant) => {
      const value = colors[key];
      const variantKey = `${key}-a${variant}`;
      obj[variantKey] = string(value) ? transform(value, variant) : generateHexAlphaVariants(value, variants);
    });
    return obj;
  }, {});
  return __spreadValues$1(__spreadValues$1({}, colors), alphaColors);
};
const defaultTones = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900];
const aliasColor = (alias, color, tones = defaultTones, variants = defaultAlphaVariants) => {
  return tones.reduce((obj, tone) => {
    obj[`${alias}-${tone}`] = th.color(`${color}-${tone}`);
    variants.forEach((i) => {
      obj[`${alias}-${tone}-a${i}`] = th.color(`${color}-${tone}-a${i}`);
    });
    return obj;
  }, {});
};

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const space = {
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  5: "1.25rem",
  6: "1.5rem",
  7: "1.75rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  11: "2.75rem",
  12: "3rem",
  14: "3.5rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  72: "18rem",
  80: "20rem",
  96: "24rem"
};
const timingFunctions = {
  "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
  "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
const transitionProperties = {
  default: [
    "background-color",
    "border-color",
    "color",
    "fill",
    "stroke",
    "opacity",
    "box-shadow",
    "transform"
  ],
  colors: ["background-color", "border-color", "color", "fill", "stroke"],
  opacity: ["opacity"],
  shadow: ["box-shadow"],
  transform: ["transform"]
};
const transitions = Object.keys(transitionProperties).reduce((obj, key) => {
  obj[key] = transitionProperties[key].map((property) => `${property} ${timingFunctions["ease-in-out"]} 150ms`).join(",");
  return obj;
}, {});
const colors = {
  black: "#000000",
  white: "#ffffff",
  "blue-gray-50": "#f8fafc",
  "blue-gray-100": "#f1f5f9",
  "blue-gray-200": "#e2e8f0",
  "blue-gray-300": "#cbd5e1",
  "blue-gray-400": "#94a3b8",
  "blue-gray-500": "#64748b",
  "blue-gray-600": "#475569",
  "blue-gray-700": "#334155",
  "blue-gray-800": "#1e293b",
  "blue-gray-900": "#0f172a",
  "cool-gray-50": "#f9fafb",
  "cool-gray-100": "#f3f4f6",
  "cool-gray-200": "#e5e7eb",
  "cool-gray-300": "#d1d5db",
  "cool-gray-400": "#9ca3af",
  "cool-gray-500": "#6b7280",
  "cool-gray-600": "#4b5563",
  "cool-gray-700": "#374151",
  "cool-gray-800": "#1f2937",
  "cool-gray-900": "#111827",
  "gray-50": "#fafafa",
  "gray-100": "#f4f4f5",
  "gray-200": "#e4e4e7",
  "gray-300": "#d4d4d8",
  "gray-400": "#a1a1aa",
  "gray-500": "#71717a",
  "gray-600": "#52525b",
  "gray-700": "#3f3f46",
  "gray-800": "#27272a",
  "gray-900": "#18181b",
  "true-gray-50": "#fafafa",
  "true-gray-100": "#f5f5f5",
  "true-gray-200": "#e5e5e5",
  "true-gray-300": "#d4d4d4",
  "true-gray-400": "#a3a3a3",
  "true-gray-500": "#737373",
  "true-gray-600": "#525252",
  "true-gray-700": "#404040",
  "true-gray-800": "#262626",
  "true-gray-900": "#171717",
  "warm-gray-50": "#fafaf9",
  "warm-gray-100": "#f5f5f4",
  "warm-gray-200": "#e7e5e4",
  "warm-gray-300": "#d6d3d1",
  "warm-gray-400": "#a8a29e",
  "warm-gray-500": "#78716c",
  "warm-gray-600": "#57534e",
  "warm-gray-700": "#44403c",
  "warm-gray-800": "#292524",
  "warm-gray-900": "#1c1917",
  "red-50": "#fef2f2",
  "red-100": "#fee2e2",
  "red-200": "#fecaca",
  "red-300": "#fca5a5",
  "red-400": "#f87171",
  "red-500": "#ef4444",
  "red-600": "#dc2626",
  "red-700": "#b91c1c",
  "red-800": "#991b1b",
  "red-900": "#7f1d1d",
  "orange-50": "#fff7ed",
  "orange-100": "#ffedd5",
  "orange-200": "#fed7aa",
  "orange-300": "#fdba74",
  "orange-400": "#fb923c",
  "orange-500": "#f97316",
  "orange-600": "#ea580c",
  "orange-700": "#c2410c",
  "orange-800": "#9a3412",
  "orange-900": "#7c2d12",
  "amber-50": "#fffbeb",
  "amber-100": "#fef3c7",
  "amber-200": "#fde68a",
  "amber-300": "#fcd34d",
  "amber-400": "#fbbf24",
  "amber-500": "#f59e0b",
  "amber-600": "#d97706",
  "amber-700": "#b45309",
  "amber-800": "#92400e",
  "amber-900": "#78350f",
  "yellow-50": "#fefce8",
  "yellow-100": "#fef9c3",
  "yellow-200": "#fef08a",
  "yellow-300": "#fde047",
  "yellow-400": "#facc15",
  "yellow-500": "#eab308",
  "yellow-600": "#ca8a04",
  "yellow-700": "#a16207",
  "yellow-800": "#854d0e",
  "yellow-900": "#713f12",
  "lime-50": "#f7fee7",
  "lime-100": "#ecfccb",
  "lime-200": "#d9f99d",
  "lime-300": "#bef264",
  "lime-400": "#a3e635",
  "lime-500": "#84cc16",
  "lime-600": "#65a30d",
  "lime-700": "#4d7c0f",
  "lime-800": "#3f6212",
  "lime-900": "#365314",
  "green-50": "#f0fdf4",
  "green-100": "#dcfce7",
  "green-200": "#bbf7d0",
  "green-300": "#86efac",
  "green-400": "#4ade80",
  "green-500": "#22c55e",
  "green-600": "#16a34a",
  "green-700": "#15803d",
  "green-800": "#166534",
  "green-900": "#14532d",
  "emerald-50": "#ecfdf5",
  "emerald-100": "#d1fae5",
  "emerald-200": "#a7f3d0",
  "emerald-300": "#6ee7b7",
  "emerald-400": "#34d399",
  "emerald-500": "#10b981",
  "emerald-600": "#059669",
  "emerald-700": "#047857",
  "emerald-800": "#065f46",
  "emerald-900": "#064e3b",
  "teal-50": "#f0fdfa",
  "teal-100": "#ccfbf1",
  "teal-200": "#99f6e4",
  "teal-300": "#5eead4",
  "teal-400": "#2dd4bf",
  "teal-500": "#14b8a6",
  "teal-600": "#0d9488",
  "teal-700": "#0f766e",
  "teal-800": "#115e59",
  "teal-900": "#134e4a",
  "cyan-50": "#ecfeff",
  "cyan-100": "#cffafe",
  "cyan-200": "#a5f3fc",
  "cyan-300": "#67e8f9",
  "cyan-400": "#22d3ee",
  "cyan-500": "#06b6d4",
  "cyan-600": "#0891b2",
  "cyan-700": "#0e7490",
  "cyan-800": "#155e75",
  "cyan-900": "#164e63",
  "light-blue-50": "#f0f9ff",
  "light-blue-100": "#e0f2fe",
  "light-blue-200": "#bae6fd",
  "light-blue-300": "#7dd3fc",
  "light-blue-400": "#38bdf8",
  "light-blue-500": "#0ea5e9",
  "light-blue-600": "#0284c7",
  "light-blue-700": "#0369a1",
  "light-blue-800": "#075985",
  "light-blue-900": "#0c4a6e",
  "blue-50": "#eff6ff",
  "blue-100": "#dbeafe",
  "blue-200": "#bfdbfe",
  "blue-300": "#93c5fd",
  "blue-400": "#60a5fa",
  "blue-500": "#3b82f6",
  "blue-600": "#2563eb",
  "blue-700": "#1d4ed8",
  "blue-800": "#1e40af",
  "blue-900": "#1e3a8a",
  "indigo-50": "#eef2ff",
  "indigo-100": "#e0e7ff",
  "indigo-200": "#c7d2fe",
  "indigo-300": "#a5b4fc",
  "indigo-400": "#818cf8",
  "indigo-500": "#6366f1",
  "indigo-600": "#4f46e5",
  "indigo-700": "#4338ca",
  "indigo-800": "#3730a3",
  "indigo-900": "#312e81",
  "violet-50": "#f5f3ff",
  "violet-100": "#ede9fe",
  "violet-200": "#ddd6fe",
  "violet-300": "#c4b5fd",
  "violet-400": "#a78bfa",
  "violet-500": "#8b5cf6",
  "violet-600": "#7c3aed",
  "violet-700": "#6d28d9",
  "violet-800": "#5b21b6",
  "violet-900": "#4c1d95",
  "purple-50": "#faf5ff",
  "purple-100": "#f3e8ff",
  "purple-200": "#e9d5ff",
  "purple-300": "#d8b4fe",
  "purple-400": "#c084fc",
  "purple-500": "#a855f7",
  "purple-600": "#9333ea",
  "purple-700": "#7e22ce",
  "purple-800": "#6b21a8",
  "purple-900": "#581c87",
  "fuchsia-50": "#fdf4ff",
  "fuchsia-100": "#fae8ff",
  "fuchsia-200": "#f5d0fe",
  "fuchsia-300": "#f0abfc",
  "fuchsia-400": "#e879f9",
  "fuchsia-500": "#d946ef",
  "fuchsia-600": "#c026d3",
  "fuchsia-700": "#a21caf",
  "fuchsia-800": "#86198f",
  "fuchsia-900": "#701a75",
  "pink-50": "#fdf2f8",
  "pink-100": "#fce7f3",
  "pink-200": "#fbcfe8",
  "pink-300": "#f9a8d4",
  "pink-400": "#f472b6",
  "pink-500": "#ec4899",
  "pink-600": "#db2777",
  "pink-700": "#be185d",
  "pink-800": "#9d174d",
  "pink-900": "#831843",
  "rose-50": "#fff1f2",
  "rose-100": "#ffe4e6",
  "rose-200": "#fecdd3",
  "rose-300": "#fda4af",
  "rose-400": "#fb7185",
  "rose-500": "#f43f5e",
  "rose-600": "#e11d48",
  "rose-700": "#be123c",
  "rose-800": "#9f1239",
  "rose-900": "#881337"
};
const fontSizes = {
  xs: "0.75rem",
  sm: "0.875rem",
  default: "1rem",
  lg: "1.125rem",
  xl: "1.25rem",
  "2xl": "1.5rem",
  "3xl": "1.875rem",
  "4xl": "2.25rem",
  "5xl": "3rem",
  "6xl": "3.75rem",
  "7xl": "4.5rem",
  "8xl": "6rem",
  "9xl": "8rem"
};
const texts = Object.keys(fontSizes).reduce((texts2, key) => {
  texts2[key] = { fontSize: key, lineHeight: key };
  return texts2;
}, {});
const defaultTheme = {
  colors: generateHexAlphaVariants(colors),
  space,
  screens: {
    _: 0,
    xs: 0,
    sm: 640,
    md: 768,
    lg: 1024,
    xl: 1280,
    "2xl": 1536
  },
  durations: {
    instant: "100ms",
    "fast-in": "250ms",
    "fast-out": "200ms",
    "slow-in": "300ms",
    "slow-out": "250ms"
  },
  sizes: __spreadProps(__spreadValues({}, space), {
    0.5: void 0,
    1: void 0,
    "0.5s": space[0.5],
    "1s": space[1],
    full: "100%",
    xs: "20rem",
    sm: "24rem",
    md: "28rem",
    lg: "32rem",
    xl: "36rem",
    "2xl": "42rem",
    "3xl": "48rem",
    "4xl": "56rem",
    "5xl": "64rem",
    "6xl": "72rem",
    "7xl": "80rem"
  }),
  radii: {
    none: "0",
    sm: "0.125rem",
    default: "0.25rem",
    md: "0.375rem",
    lg: "0.5rem",
    xl: "0.75rem",
    "2xl": "1rem",
    "3xl": "1.5rem",
    full: "9999px"
  },
  shadows: {
    xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
    sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
    default: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
    md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
    lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
    xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
    "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
    inner: "inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)",
    outline: "0 0 0 3px rgba(66, 153, 225, 0.5)"
  },
  fontSizes,
  fontWeights: {
    hairline: "100",
    thin: "200",
    light: "300",
    normal: "400",
    medium: "500",
    semibold: "600",
    bold: "700",
    extrabold: "800",
    black: "900"
  },
  fonts: {
    mono: `ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`,
    serif: `ui-serif, Georgia, Cambria, "Times New Roman", Times, serif`,
    sans: `ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"`
  },
  letterSpacings: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0em",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeights: {
    none: 1,
    tight: 1.25,
    snug: 1.375,
    normal: 1.5,
    relaxed: 1.625,
    loose: 2,
    3: ".75rem",
    4: "1rem",
    5: "1.25rem",
    6: "1.5rem",
    7: "1.75rem",
    8: "2rem",
    9: "2.25rem",
    10: "2.5rem",
    xs: "1rem",
    sm: "1.25rem",
    default: "1.5rem",
    lg: "1.75rem",
    xl: "1.75rem",
    "2xl": "2rem",
    "3xl": "2.25rem",
    "4xl": "2.5rem",
    "5xl": 1,
    "6xl": 1,
    "7xl": 1,
    "8xl": 1,
    "9xl": 1
  },
  gridTemplateColumns: {
    1: "repeat(1, minmax(0, 1fr))",
    2: "repeat(2, minmax(0, 1fr))",
    3: "repeat(3, minmax(0, 1fr))",
    4: "repeat(4, minmax(0, 1fr))",
    5: "repeat(5, minmax(0, 1fr))",
    6: "repeat(6, minmax(0, 1fr))",
    7: "repeat(7, minmax(0, 1fr))",
    8: "repeat(8, minmax(0, 1fr))",
    9: "repeat(9, minmax(0, 1fr))",
    10: "repeat(10, minmax(0, 1fr))",
    11: "repeat(11, minmax(0, 1fr))",
    12: "repeat(12, minmax(0, 1fr))"
  },
  gridTemplateRows: {
    1: "repeat(1, minmax(0, 1fr))",
    2: "repeat(2, minmax(0, 1fr))",
    3: "repeat(3, minmax(0, 1fr))",
    4: "repeat(4, minmax(0, 1fr))",
    5: "repeat(5, minmax(0, 1fr))",
    6: "repeat(6, minmax(0, 1fr))"
  },
  borderWidths: {
    default: 1
  },
  ringWidths: {
    default: 3
  },
  borders: {
    default: "1px solid transparent"
  },
  texts,
  transitions,
  transitionProperties,
  timingFunctions,
  animations: {
    spin: "x-spin 1s linear infinite",
    ping: "x-ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
    pulse: "x-pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
    bounce: "x-bounce 1s infinite"
  },
  states: {
    _: null,
    motionSafe: "@media (prefers-reduced-motion: no-preference)",
    motionReduce: "@media (prefers-reduced-motion: reduce)",
    first: "&:first-child",
    last: "&:last-child",
    odd: "&:odd",
    even: "&:even",
    visited: "&:visited",
    checked: "&:checked",
    focusWithin: "&:focus-within",
    hover: "&:hover",
    focus: "&:focus",
    focusVisible: "&:focus-visible",
    active: "&:active",
    disabled: "&:disabled, &[aria-disabled=true]",
    placeholder: "&::placeholder"
  }
};

const getPreflightStyles = (theme) => `
/*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */
*,::after,::before{box-sizing:border-box}:root{-moz-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial,sans-serif,'Apple Color Emoji','Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Consolas,'Liberation Mono',Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}

/* Role button pointer */
[role=button], button {
  cursor: pointer;
}

/* Remove default margins */
blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

/* Remove headings styles */
h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Unstyle lists */
ol,
ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

/* Image are block-level */
img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block;
  vertical-align: middle;
}

/* Reset border styles */
*,
::before,
::after {
  border-width: 0;
  border-style: solid;
  border-color: ${th.color("default-border-color", "currentColor")({ theme })};
}

* {
  --x-ring-color: ${th.color("default-ring-color", "rgba(59,130,246,0.5)")({ theme })};
}

/* Default outline on buttons */
button:focus {
  outline: 1px dotted;
  outline: 5px auto -webkit-focus-ring-color;
}

// Animations
@keyframes x-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes x-ping {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  75%, 100% {
    transform: scale(2);
    opacity: 0;
  }
}

@keyframes x-pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: .5;
  }
}

@keyframes x-bounce {
  0%, 100% {
    transform: translateY(-25%);
    animationTimingFunction: cubic-bezier(0.8, 0, 1, 1);
  }
  50% {
    transform: translateY(0);
    animationTimingFunction: cubic-bezier(0, 0, 0.2, 1);
  }
}
`;

export { aliasColor, alignContent, alignItems, alignSelf, animation, animationDuration, animationTimingFunction, animations, appearance, background, backgroundAttachment, backgroundClip, backgroundColor, backgroundImage, backgroundPosition, backgroundRepeat, backgroundSize, backgrounds, between, border, borderBottom, borderBottomColor, borderBottomStyle, borderBottomWidth, borderCollapse, borderColor, borderLeft, borderLeftColor, borderLeftStyle, borderLeftWidth, borderRadius, borderRight, borderRightColor, borderRightStyle, borderRightWidth, borderStyle, borderTop, borderTopColor, borderTopStyle, borderTopWidth, borderWidth, borders, bottom, boxShadow, boxSizing, breakpoints, col, color, columnGap, compose, container, createStyleGenerator, cursor, defaultTheme, display, divideColor, divideStyle, divideX, divideXReverse, divideY, divideYReverse, down, effects, fill, flex, flexBasis, flexDirection, flexGrow, flexShrink, flexWrap, flexboxGrids, flexboxes, float, fontFamily, fontSize, fontStyle, fontWeight, gap, generateHexAlphaVariants, getAngle, getAnimation, getBorder, getBorderColor, getBorderStyle, getBorderWidth, getBreakpointMax, getBreakpointMin, getColor, getDuration, getFont, getFontSize, getFontWeight, getInset, getLetterSpacing, getLineHeight, getPercent, getPreflightStyles, getPx, getRadius, getRingWidth, getScreens, getShadow, getSize, getSpace, getStates, getTimingFunction, getTransform, getTransition, getTransitionProperty, getVariants, getZIndex, gradientFrom, gradientTo, gradientVia, gridArea, gridAutoColumns, gridAutoFlow, gridAutoRows, gridColumn, gridRow, gridTemplateAreas, gridTemplateColumns, gridTemplateRows, grids, height, interactivity, justifyContent, justifyItems, justifySelf, layout, left, letterSpacing, lineHeight, listStylePosition, listStyleType, margin, marginBottom, marginLeft, marginRight, marginTop, maskSize, maxHeight, maxWidth, minHeight, minWidth, mx, my, objectFit, opacity, order, outline, outlineColor, outlineOffset, outlineStyle, outlineWidth, overflow, overflowX, overflowY, overscrollBehavior, padding, paddingBottom, paddingLeft, paddingRight, paddingTop, pointerEvents, position, px, py, resize, right, ring, ringColor, ringInset, rotate, row, rowGap, rpxTransformers, scale, scaleX, scaleY, sizing, skewX, skewY, space$1 as space, spaceX, spaceXReverse, spaceY, spaceYReverse, stroke, style, svg, system, tableLayout, tables, text, textAlign, textDecoration, textOverflow, textShadow, textTransform, th, themeGetter, top, transform, transformOrigin, transforms, transition, transitionDelay, transitionDuration, transitionProperty, transitionTimingFunction, transitions$1 as transitions, translateX, translateY, typography, up, userSelect, verticalAlign, visibility, whiteSpace, width, zIndex };
//# sourceMappingURL=index.mjs.map
