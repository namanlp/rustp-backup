import * as React from 'react';
import { useMemo } from 'react';
import { getScreens, system, getBreakpointMax, getBreakpointMin } from '@xstyled/system';
import { obj, string, func, cascade } from '@xstyled/util';

function useThemeScreens(theme) {
  return getScreens({ theme });
}
function useThemeMinValue(theme, key) {
  const screens = useThemeScreens(theme);
  const value = screens[key];
  return value === 0 ? null : value;
}
function useThemeMaxValue(theme, key) {
  const screens = useThemeScreens(theme);
  const breakPoint = screens[key];
  return breakPoint === 0 ? null : breakPoint - 0.02;
}
function useViewportWidth() {
  const [width, setWidth] = React.useState(typeof window === "undefined" ? null : window.innerWidth);
  React.useEffect(() => {
    function handleResize() {
      setWidth(window.innerWidth);
    }
    window.addEventListener("resize", handleResize);
    setWidth(window.innerWidth);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return width;
}
function useThemeBreakpoint(theme) {
  const screns = useThemeScreens(theme);
  const width = useViewportWidth();
  return React.useMemo(() => {
    return Object.keys(screns).reverse().find((screen) => width !== null && width > screns[screen]) || null;
  }, [screns, width]);
}
function useThemeUp(theme, key) {
  const value = useThemeMinValue(theme, key);
  const width = useViewportWidth();
  return width !== null && value !== null && width >= value;
}
function useThemeDown(theme, key) {
  const value = useThemeMaxValue(theme, key);
  const width = useViewportWidth();
  return width !== null && value !== null && width < value;
}

const join = (...args) => args.filter(Boolean).join(".");
const toVarName = (key) => `--${key.replace(/\./g, "-")}`;
const toVarValue = (key, value) => `var(${toVarName(key)}, ${value})`;
const toProp = (key, value) => `${key}: ${value};`;
function toCustomPropertiesReferences(values, theme, keys = Object.keys(values), parent) {
  const next = Array.isArray(values) ? [] : {};
  for (const i in keys) {
    const key = keys[i];
    const value = values[key];
    const name = join(parent, key);
    if (obj(value)) {
      next[key] = toCustomPropertiesReferences(value, theme, Object.keys(value), name);
      continue;
    }
    if (string(value)) {
      next[key] = toVarValue(name, value);
      continue;
    }
    if (func(value)) {
      next[key] = toVarValue(name, cascade(value, { theme }));
      continue;
    }
  }
  return next;
}
function toCustomPropertiesDeclarations(values, theme, keys = Object.keys(values), parent, state = { value: "" }) {
  for (const i in keys) {
    const key = keys[i];
    const value = values[key];
    const name = join(parent, key);
    if (obj(value)) {
      toCustomPropertiesDeclarations(value, theme, Object.keys(value), name, state);
      continue;
    }
    if (string(value)) {
      state.value += toProp(toVarName(name), value);
      continue;
    }
    if (func(value)) {
      state.value += toProp(toVarName(name), cascade(value, { theme }));
      continue;
    }
  }
  return state.value;
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const STORAGE_KEY = "xstyled-color-mode";
const isLocalStorageAvailable = typeof window !== "undefined" && (() => {
  try {
    const key = "xstyled-test-key";
    window.localStorage.setItem(key, key);
    window.localStorage.removeItem(key);
    return true;
  } catch (err) {
    return false;
  }
})();
const storage = isLocalStorageAvailable ? {
  get: () => window.localStorage.getItem(STORAGE_KEY),
  set: (value) => {
    window.localStorage.setItem(STORAGE_KEY, value);
  },
  clear: () => window.localStorage.removeItem(STORAGE_KEY)
} : {
  get: () => null,
  set: () => {
  },
  clear: () => {
  }
};
const COLOR_MODE_CLASS_PREFIX = "xstyled-color-mode-";
const getColorModeClassName = (mode) => `${COLOR_MODE_CLASS_PREFIX}${mode}`;
const XSTYLED_COLORS_PREFIX = "xstyled-colors";
const SYSTEM_MODES = ["light", "dark"];
function getModeTheme(theme, mode) {
  return __spreadProps(__spreadValues({}, theme), {
    colors: __spreadValues(__spreadValues({}, theme.colors), theme.colors.modes[mode])
  });
}
const getMediaQuery = (query) => `@media ${query}`;
const getColorModeQuery = (mode) => `(prefers-color-scheme: ${mode})`;
function checkHasColorModes(theme) {
  return Boolean(theme && theme.colors && theme.colors.modes);
}
function checkHasCustomPropertiesEnabled(theme) {
  return Boolean(theme && (theme.useCustomProperties === void 0 || theme.useCustomProperties));
}
function checkHasMediaQueryEnabled(theme) {
  return Boolean(theme && (theme.useColorSchemeMediaQuery === void 0 || theme.useColorSchemeMediaQuery));
}
function getInitialColorModeName(theme) {
  return theme.initialColorModeName || "default";
}
function getDefaultColorModeName(theme) {
  return theme.defaultColorModeName || getInitialColorModeName(theme);
}
function getUsedColorKeys(modes) {
  let keys = [];
  for (const key in modes) {
    keys = [...keys, ...Object.keys(modes[key])];
  }
  return keys;
}
function createColorStyles(theme, { targetSelector = "body" } = {}) {
  if (!checkHasColorModes(theme))
    return null;
  const _a = theme.colors, { modes } = _a, colors = __objRest(_a, ["modes"]);
  const colorKeys = getUsedColorKeys(modes);
  let styles = toCustomPropertiesDeclarations(colors, theme, colorKeys, XSTYLED_COLORS_PREFIX);
  function getModePropertiesDeclarations(mode) {
    const modeTheme = getModeTheme(theme, mode);
    const _a2 = modeTheme.colors, { modes: modes2 } = _a2, colors2 = __objRest(_a2, ["modes"]);
    return toCustomPropertiesDeclarations(__spreadValues(__spreadValues({}, colors2), modes2[mode]), modeTheme, colorKeys, XSTYLED_COLORS_PREFIX);
  }
  if (theme.useColorSchemeMediaQuery !== false) {
    SYSTEM_MODES.forEach((mode) => {
      if (modes[mode]) {
        const mediaQuery = getMediaQuery(getColorModeQuery(mode));
        styles += `${mediaQuery}{${getModePropertiesDeclarations(mode)}}`;
      }
    });
  }
  const initialModeName = getInitialColorModeName(theme);
  [initialModeName, ...Object.keys(modes)].forEach((mode) => {
    const key = `&.${getColorModeClassName(mode)}`;
    styles += `${key}{${getModePropertiesDeclarations(mode)}}`;
  });
  return `${targetSelector}{${styles}}`;
}
function getSystemModeMql(mode) {
  if (typeof window === "undefined" || window.matchMedia === void 0) {
    return null;
  }
  const query = getColorModeQuery(mode);
  return window.matchMedia(query);
}
function useSystemMode(theme) {
  const configs = React.useMemo(() => {
    if (!checkHasMediaQueryEnabled(theme))
      return [];
    return SYSTEM_MODES.map((mode) => {
      if (!checkHasColorModes(theme))
        return null;
      if (!theme.colors.modes[mode])
        return null;
      const mql = getSystemModeMql(mode);
      return mql ? { mode, mql } : null;
    }).filter(Boolean);
  }, [theme]);
  const [systemMode, setSystemMode] = React.useState(() => {
    const config = configs.find((config2) => config2.mql.matches);
    return config ? config.mode : null;
  });
  React.useEffect(() => {
    const cleans = configs.map(({ mode, mql }) => {
      const handler = ({ matches }) => {
        if (matches) {
          setSystemMode(mode);
        } else {
          setSystemMode((previousMode) => previousMode === mode ? null : mode);
        }
      };
      mql.addEventListener("change", handler);
      return () => mql.removeEventListener("change", handler);
    });
    return () => cleans.forEach((clean) => clean());
  });
  return systemMode;
}
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
function useColorModeState(theme, { target } = {}) {
  const systemMode = useSystemMode(theme);
  const defaultColorMode = getDefaultColorModeName(theme);
  const initialColorMode = getInitialColorModeName(theme);
  const [mode, setMode] = React.useState(() => {
    if (!checkHasColorModes(theme))
      return null;
    return defaultColorMode;
  });
  const customPropertiesEnabled = checkHasCustomPropertiesEnabled(theme);
  const manualSetRef = React.useRef(false);
  const manuallySetMode = React.useCallback((value) => {
    manualSetRef.current = true;
    setMode(value);
  }, []);
  useIsomorphicLayoutEffect(() => {
    if (!checkHasColorModes(theme))
      return;
    const storedMode = storage.get();
    const initialMode = storedMode || systemMode || defaultColorMode;
    if (mode !== initialMode) {
      setMode(storedMode || systemMode || defaultColorMode);
    }
  }, []);
  useIsomorphicLayoutEffect(() => {
    if (manualSetRef.current) {
      if (mode) {
        storage.set(mode);
      } else {
        storage.clear();
      }
    }
  }, [mode]);
  useIsomorphicLayoutEffect(() => {
    const storedMode = storage.get();
    if (storedMode)
      return;
    const targetMode = systemMode || defaultColorMode;
    if (targetMode === mode)
      return;
    setMode(targetMode);
  }, [mode, systemMode, defaultColorMode]);
  useIsomorphicLayoutEffect(() => {
    if (!mode)
      return void 0;
    if (!customPropertiesEnabled)
      return void 0;
    const stored = storage.get();
    const initial = initialColorMode !== mode;
    if (!stored && !initial)
      return void 0;
    const className = getColorModeClassName(mode);
    const usedTarget = target || document.body;
    usedTarget.classList.add(className);
    return () => {
      usedTarget.classList.remove(className);
    };
  }, [customPropertiesEnabled, target, mode, initialColorMode]);
  return [mode, manuallySetMode];
}
function useColorModeTheme(theme, mode) {
  const [initialMode] = React.useState(mode);
  const customPropertiesTheme = React.useMemo(() => {
    if (!initialMode)
      return null;
    if (!checkHasCustomPropertiesEnabled(theme))
      return null;
    if (!checkHasColorModes(theme))
      return theme;
    const _a = theme.colors, { modes } = _a, colors = __objRest(_a, ["modes"]);
    const colorKeys = getUsedColorKeys(modes);
    return __spreadProps(__spreadValues({}, theme), {
      colors: __spreadProps(__spreadValues(__spreadValues({}, colors), toCustomPropertiesReferences(colors, theme, colorKeys, XSTYLED_COLORS_PREFIX)), {
        modes
      }),
      __rawColors: theme.colors
    });
  }, [initialMode, theme]);
  const swapModeTheme = React.useMemo(() => {
    if (!mode)
      return null;
    if (checkHasCustomPropertiesEnabled(theme))
      return null;
    if (!checkHasColorModes(theme))
      return theme;
    if (mode === getInitialColorModeName(theme)) {
      return __spreadProps(__spreadValues({}, theme), { __colorMode: mode });
    }
    return __spreadProps(__spreadValues({}, theme), {
      colors: __spreadValues(__spreadValues({}, theme.colors), theme.colors.modes[mode]),
      __colorMode: mode,
      __rawColors: theme.colors
    });
  }, [theme, mode]);
  return customPropertiesTheme || swapModeTheme;
}
const ColorModeContext = React.createContext(null);
function useColorMode() {
  const colorModeState = React.useContext(ColorModeContext);
  if (!colorModeState) {
    throw new Error(`[useColorMode] requires the ColorModeProvider component`);
  }
  return colorModeState;
}
function createColorModeProvider({
  ThemeContext,
  ThemeProvider,
  ColorModeStyle
}) {
  function ColorModeProvider({
    children,
    target,
    targetSelector
  }) {
    const theme = React.useContext(ThemeContext);
    if (!theme) {
      throw new Error("[ColorModeProvider] requires ThemeProvider upper in the tree");
    }
    const colorState = useColorModeState(theme, { target });
    const colorModeTheme = useColorModeTheme(theme, colorState[0]);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ColorModeStyle, {
      targetSelector
    }), /* @__PURE__ */ React.createElement(ThemeProvider, {
      theme: colorModeTheme
    }, /* @__PURE__ */ React.createElement(ColorModeContext.Provider, {
      value: colorState
    }, children)));
  }
  return ColorModeProvider;
}
function getInitScript({
  target = "document.body"
} = {}) {
  return `(function() { try {
    var mode = localStorage.getItem('${STORAGE_KEY}');
    if (mode) ${target}.classList.add('${COLOR_MODE_CLASS_PREFIX}' + mode);
  } catch (e) {} })();`;
}
function getColorModeInitScriptElement(options) {
  return /* @__PURE__ */ React.createElement("script", {
    key: "xstyled-color-mode-init",
    dangerouslySetInnerHTML: { __html: getInitScript(options) }
  });
}
function getColorModeInitScriptTag(options) {
  return `<script>${getInitScript(options)}<\/script>`;
}

function createBox() {
  return [`&&{`, system, `}`];
}
createBox.meta = system.meta;

const getMediaWidth = (getBreakpointBound) => (value) => (props) => {
  const v = getBreakpointBound(getScreens(props), value);
  return v === null ? "0" : v || value;
};
const mediaGetters = {
  "min-width": getMediaWidth(getBreakpointMin),
  "max-width": getMediaWidth(getBreakpointMax)
};

const PROP_CHAR = `[-\\w]`;
const VALUE_CHAR = `(?:\\\\[\\s\\S]|[^\\\\;{}])`;
const PROP_PATT = `(${PROP_CHAR}+)(\\s*:\\s*)(?=\\S)(${VALUE_CHAR}*?)(\\s*!important)?(\\s*;)`;
const MEDIA_CHAR = `[^{]`;
const MEDIA_PATT = `(@media\\b\\s*)(?=\\S)(${MEDIA_CHAR}+?)(\\s*\\{)`;
const MATCH_REGEXP = new RegExp(`(?:${PROP_PATT}|${MEDIA_PATT})`, `g`);
const QUERY_REGEXP = new RegExp(`(\\(\\s*)(${PROP_CHAR}+)(\\s*:\\s*)([^\\)]*?)(\\s*\\))`, `g`);
const mediaTransform = (rawValue) => {
  let matches;
  let lastIndex = 0;
  const values = [];
  while (matches = QUERY_REGEXP.exec(rawValue)) {
    const [, open, prop, colon, value, close] = matches;
    const getter = mediaGetters[prop];
    if (getter) {
      values.push(rawValue.slice(lastIndex, matches.index));
      values.push((p) => `${open}${prop}${colon}${getter(value)(p)}${close}`);
      lastIndex = matches.index + matches[0].length;
    }
  }
  values.push(rawValue.slice(lastIndex, rawValue.length));
  return values;
};
const createTransform = (generator) => (rawValue) => {
  if (typeof rawValue !== "string")
    return rawValue;
  let matches;
  let lastIndex = 0;
  const values = [];
  while (matches = MATCH_REGEXP.exec(rawValue)) {
    const [, prop, colon, value, imp, semi, media, query, brace] = matches;
    if (media) {
      values.push(rawValue.slice(lastIndex, matches.index));
      values.push(media);
      mediaTransform(query).forEach((v) => values.push(v));
      values.push(brace);
      lastIndex = matches.index + matches[0].length;
    } else {
      const getter = generator.meta.cssGetters[prop];
      if (getter) {
        values.push(rawValue.slice(lastIndex, matches.index));
        values.push((p) => `${prop}${colon}${getter(value)(p)}${imp || ""}${semi}`);
        lastIndex = matches.index + matches[0].length;
      }
    }
  }
  values.push(rawValue.slice(lastIndex, rawValue.length));
  return values;
};

const createUseGetter = (getter, useTheme) => (value, defaultValue) => {
  const theme = useTheme();
  return useMemo(() => getter(value, defaultValue)({ theme }), [value, defaultValue, theme]);
};

export { ColorModeContext, createBox, createColorModeProvider, createColorStyles, createTransform, createUseGetter, getColorModeInitScriptElement, getColorModeInitScriptTag, useColorMode, useColorModeState, useColorModeTheme, useThemeBreakpoint, useThemeDown, useThemeScreens, useThemeUp, useViewportWidth };
//# sourceMappingURL=index.mjs.map
