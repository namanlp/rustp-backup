import { useRef, useState, useMemo, useEffect } from 'react';
import { getPopupRole } from 'ariakit-utils/dom';
import { queueBeforeEvent, isFocusEventOutside } from 'ariakit-utils/events';
import { useForceUpdate, useUpdateLayoutEffect, useSafeLayoutEffect, useBooleanEvent, useEvent, useId, useForkRef } from 'ariakit-utils/hooks';
import { normalizeString } from 'ariakit-utils/misc';
import { createHook, createComponent, createElement } from 'ariakit-utils/system';
import { useComposite } from '../composite/composite.js';
import { usePopoverAnchor } from '../popover/popover-anchor.js';

function isFirstItemAutoSelected(items, activeValue, autoSelect) {
  if (!autoSelect) return false;
  const firstItem = items.find(item => !item.disabled && item.value);
  return (firstItem == null ? void 0 : firstItem.value) === activeValue;
}

function hasCompletionString(value, activeValue) {
  if (!activeValue) return false;
  if (value == null) return false;
  value = normalizeString(value);
  return activeValue.length > value.length && activeValue.toLowerCase().indexOf(value.toLowerCase()) === 0;
}

function isInputEvent(event) {
  return event.type === "input";
}
/**
 * A component hook that returns props that can be passed to `Role` or any other
 * Ariakit component to render a combobox input.
 * @see https://ariakit.org/components/combobox
 * @example
 * ```jsx
 * const state = useComboboxState();
 * const props = useCombobox({ state });
 * <Role {...props} />
 * <ComboboxPopover state={state}>
 *   <ComboboxItem value="Item 1" />
 *   <ComboboxItem value="Item 2" />
 *   <ComboboxItem value="Item 3" />
 * </ComboboxPopover>
 * ```
 */


const useCombobox = createHook(_ref => {
  var _state$contentElement;

  let {
    state,
    focusable = true,
    autoSelect = false,
    showOnChange = true,
    setValueOnChange = true,
    showOnMouseDown = true,
    setValueOnClick = true,
    showOnKeyDown = true,
    moveOnKeyPress = true,
    autoComplete = state.list.length ? "list" : "none",
    ...props
  } = _ref;
  const ref = useRef(null);
  const [valueUpdated, forceValueUpdate] = useForceUpdate();
  const valueChangedRef = useRef(false); // We can only allow auto select when the combobox focus is handled via the
  // aria-activedescendant attribute. Othwerwise, the focus would move to the
  // first item on every keypress.

  autoSelect = !!autoSelect && state.virtualFocus;
  const inline = autoComplete === "inline" || autoComplete === "both"; // The inline autocomplete should only happen in certain circumstances. We
  // control this state here.

  const [canInline, setCanInline] = useState(inline); // If the inline autocomplete is enabled in a update, we need to update the
  // canInline state to reflect this.

  useUpdateLayoutEffect(() => {
    if (!inline) return;
    setCanInline(true);
  }, [inline]); // The current input value may differ from state.value when
  // autoComplete is either "both" or "inline", in which case it will be
  // the active item value or a combination of the input value and the active
  // item value if it's the first item and it's been auto selected. This will
  // only affect the element's value, not the combobox state.

  const value = useMemo(() => {
    if (!inline) return state.value;
    if (!canInline) return state.value;
    const firstItemAutoSelected = isFirstItemAutoSelected(state.items, state.activeValue, autoSelect);

    if (firstItemAutoSelected) {
      // If the first item is auto selected, we should append the completion
      // string to the end of the value. This will be highlited in the effect
      // below.
      if (hasCompletionString(state.value, state.activeValue)) {
        var _state$activeValue;

        const slice = ((_state$activeValue = state.activeValue) == null ? void 0 : _state$activeValue.slice(state.value.length)) || "";
        return state.value + slice;
      }

      return state.value;
    }

    return state.activeValue || state.value;
  }, [inline, state.value, canInline, state.items, autoSelect, state.activeValue]); // Listen to the combobox-item-move event that's dispacthed the ComboboxItem
  // component so we can enable the inline autocomplete when the user moves
  // the focus to an item using the keyboard.

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const onCompositeItemMove = () => setCanInline(true);

    element.addEventListener("combobox-item-move", onCompositeItemMove);
    return () => {
      element.removeEventListener("combobox-item-move", onCompositeItemMove);
    };
  }, []); // Highlights the completion string

  useEffect(() => {
    if (!inline) return;
    if (!canInline) return;
    if (!state.activeValue) return;
    const firstItemAutoSelected = isFirstItemAutoSelected(state.items, state.activeValue, autoSelect);
    if (!firstItemAutoSelected) return;
    if (!hasCompletionString(state.value, state.activeValue)) return;
    const element = ref.current;
    if (!element) return;
    element.setSelectionRange(state.value.length, state.activeValue.length);
  }, [valueUpdated, inline, canInline, state.activeValue, state.items, autoSelect, state.value]); // Set the changed flag to true whenever the combobox value changes and is
  // not empty. We're doing this here in addition to in the onChange handler
  // because the value may change programmatically.

  useUpdateLayoutEffect(() => {
    if (!state.value) return;
    valueChangedRef.current = true;
  }, [state.value]); // Reset the changed flag when the popover is not open so we don't try to
  // auto select an item after the popover closes (for example, in the middle
  // of an animation).

  useSafeLayoutEffect(() => {
    if (state.open) return;
    valueChangedRef.current = false;
  }, [state.open]); // Auto select the first item on type. This effect runs both when the value
  // changes and when the items change so we also catch async items. This
  // needs to be a layout effect to avoid a flash of unselected content.

  useUpdateLayoutEffect(() => {
    if (!autoSelect) return;
    if (!state.items.length) return;
    if (!valueChangedRef.current) return;
    state.move(state.first());
  }, [valueUpdated, state.value, autoSelect, state.items, state.move, state.first]); // Focus on the combobox input on type.

  useSafeLayoutEffect(() => {
    if (autoSelect) return;
    state.setActiveId(null);
  }, [valueUpdated, autoSelect, state.setActiveId]); // If it has inline auto completion, set the state value when the combobox
  // input or the combobox list lose focus.

  useEffect(() => {
    if (!inline) return;
    const combobox = ref.current;
    if (!combobox) return;
    const elements = [combobox, state.contentElement].filter(Boolean);

    const onBlur = event => {
      if (elements.every(el => isFocusEventOutside(event, el))) {
        state.setValue(value);
      }
    };

    elements.forEach(el => el == null ? void 0 : el.addEventListener("focusout", onBlur));
    return () => {
      elements.forEach(el => el == null ? void 0 : el.removeEventListener("focusout", onBlur));
    };
  }, [inline, state.contentElement, state.setValue, value]);
  const onChangeProp = props.onChange;
  const showOnChangeProp = useBooleanEvent(showOnChange);
  const setValueOnChangeProp = useBooleanEvent(setValueOnChange);
  const onChange = useEvent(event => {
    onChangeProp == null ? void 0 : onChangeProp(event);
    if (event.defaultPrevented) return;
    const {
      target
    } = event;
    const nativeEvent = event.nativeEvent;
    valueChangedRef.current = true;

    if (isInputEvent(nativeEvent) && inline) {
      const textInserted = nativeEvent.inputType === "insertText";
      const caretAtEnd = target.selectionStart === target.value.length;
      setCanInline(textInserted && caretAtEnd);
    }

    if (showOnChangeProp(event)) {
      state.show();
    }

    if (setValueOnChangeProp(event)) {
      state.setValue(target.value);
    }

    if (inline && autoSelect) {
      // The state.setValue(event.target.value) above may not trigger a state
      // update. For example, say the first item starts with "t". The user
      // starts typing "t", then the first item is auto selected and the
      // inline completion string is appended and highlited. The user then
      // selects all the text and type "t" again. This change will produce the
      // same value as the state value, and therefore the state update will
      // not trigger a re-render. We need to force a re-render here so the
      // inline completion effect will be fired.
      forceValueUpdate();
    }

    if (!autoSelect || !valueChangedRef.current) {
      // If autoSelect is not set or it's not an insertion of text, focus on
      // the combobox input after changing the value.
      state.setActiveId(null);
    }
  });
  const onCompositionEndProp = props.onCompositionEnd; // When dealing with composition text (for example, when the user is typing
  // in accents or chinese characters), we need to set hasInsertedTextRef to
  // true when the composition ends. This is because the native input event
  // that's passed to the change event above will not produce a consistent
  // inputType value across browsers, so we can't rely on that there.

  const onCompositionEnd = useEvent(event => {
    onCompositionEndProp == null ? void 0 : onCompositionEndProp(event);
    if (event.defaultPrevented) return;
    valueChangedRef.current = true;
    if (!autoSelect) return;
    forceValueUpdate();
  });
  const onMouseDownProp = props.onMouseDown;
  const setValueOnClickProp = useBooleanEvent(setValueOnClick);
  const showOnMouseDownProp = useBooleanEvent(showOnMouseDown);
  const onMouseDown = useEvent(event => {
    onMouseDownProp == null ? void 0 : onMouseDownProp(event);
    if (event.defaultPrevented) return;
    if (event.button) return;
    if (event.ctrlKey) return;
    state.setActiveId(null);

    if (setValueOnClickProp(event)) {
      state.setValue(value);
    }

    if (showOnMouseDownProp(event)) {
      queueBeforeEvent(event.currentTarget, "mouseup", state.show);
    }
  });
  const onKeyDownProp = props.onKeyDown;
  const showOnKeyDownProp = useBooleanEvent(showOnKeyDown);
  const onKeyDown = useEvent(event => {
    onKeyDownProp == null ? void 0 : onKeyDownProp(event);
    if (event.defaultPrevented) return;
    valueChangedRef.current = false;
    if (event.ctrlKey) return;
    if (event.altKey) return;
    if (event.shiftKey) return;
    if (event.metaKey) return;
    if (state.open) return;
    if (state.activeId !== null) return; // Up and Down arrow keys should open the combobox popover.

    if (event.key === "ArrowUp" || event.key === "ArrowDown") {
      if (showOnKeyDownProp(event)) {
        event.preventDefault();
        state.show();
      }
    }
  });
  const onBlurProp = props.onBlur;
  const onBlur = useEvent(event => {
    onBlurProp == null ? void 0 : onBlurProp(event);
    if (event.defaultPrevented) return;
    valueChangedRef.current = false;
  }); // This is necessary so other components like ComboboxCancel can reference
  // the combobox input in their aria-controls attribute.

  const id = useId(props.id);
  props = {
    id,
    role: "combobox",
    "aria-autocomplete": autoComplete,
    "aria-haspopup": getPopupRole(state.contentElement, "listbox"),
    "aria-expanded": state.open,
    "aria-controls": (_state$contentElement = state.contentElement) == null ? void 0 : _state$contentElement.id,
    value,
    ...props,
    ref: useForkRef(ref, props.ref),
    onChange,
    onCompositionEnd,
    onMouseDown,
    onKeyDown,
    onBlur
  };
  const moveOnKeyPressProp = useBooleanEvent(moveOnKeyPress);
  props = useComposite({
    state,
    focusable,
    ...props,
    // Enable inline autocomplete when the user moves from the combobox input
    // to an item.
    moveOnKeyPress: event => {
      if (!moveOnKeyPressProp(event)) return false;
      if (inline) setCanInline(true);
      return true;
    }
  });
  props = usePopoverAnchor({
    state,
    ...props
  });
  return {
    autoComplete: "off",
    ...props
  };
});
/**
 * A component that renders a combobox input.
 * @see https://ariakit.org/components/combobox
 * @example
 * ```jsx
 * const combobox = useComboboxState();
 * <Combobox state={combobox} />
 * <ComboboxPopover state={combobox}>
 *   <ComboboxItem value="Item 1" />
 *   <ComboboxItem value="Item 2" />
 *   <ComboboxItem value="Item 3" />
 * </ComboboxPopover>
 * ```
 */

const Combobox = createComponent(props => {
  const htmlProps = useCombobox(props);
  return createElement("input", htmlProps);
});

if (process.env.NODE_ENV !== "production") {
  Combobox.displayName = "Combobox";
}

export { Combobox, useCombobox };
