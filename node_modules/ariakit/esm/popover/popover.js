import { useState } from 'react';
import { useSafeLayoutEffect, usePortalRef, useWrapElement } from 'ariakit-utils/hooks';
import { createHook, createComponent, createElement } from 'ariakit-utils/system';
import { useDialog } from '../dialog/dialog.js';
import { P as PopoverContext } from '../__utils-3e6151ed.js';
import { jsx } from 'react/jsx-runtime';

/**
 * A component hook that returns props that can be passed to `Role` or any other
 * Ariakit component to render a popover element.
 * @see https://ariakit.org/components/popover
 * @example
 * ```jsx
 * const state = usePopoverState();
 * const props = usePopover({ state });
 * <Role {...props}>Popover</Role>
 * ```
 */
const usePopover = createHook(_ref => {
  let {
    state,
    modal = false,
    portal = !!modal,
    preserveTabOrder = true,
    autoFocusOnShow = true,
    wrapperProps,
    ...props
  } = _ref;
  const popoverRef = state.popoverRef; // Makes sure the wrapper element that's passed to popper has the same
  // z-index as the popover element so users only need to set the z-index
  // once.

  useSafeLayoutEffect(() => {
    const wrapper = popoverRef.current;
    const popover = state.contentElement;
    if (!wrapper) return;
    if (!popover) return;
    wrapper.style.zIndex = getComputedStyle(popover).zIndex;
  }, [popoverRef, state.contentElement]); // We have to wait for the popover to be positioned before we can move
  // focus, otherwise there may be scroll jumps. See popover-standalone
  // example test-browser file.

  const [canAutoFocusOnShow, setCanAutoFocusOnShow] = useState(false);
  const {
    portalRef,
    domReady
  } = usePortalRef(portal, props.portalRef);
  useSafeLayoutEffect(() => {
    var _state$contentElement;

    if (!domReady) return;
    if (!state.mounted) return;
    if (!((_state$contentElement = state.contentElement) != null && _state$contentElement.isConnected)) return;
    const raf = requestAnimationFrame(() => {
      setCanAutoFocusOnShow(true);
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [domReady, state.mounted, state.contentElement]); // Wrap our element in a div that will be used to position the popover.
  // This way the user doesn't need to override the popper's position to
  // create animations.

  props = useWrapElement(props, element => /*#__PURE__*/jsx("div", {
    role: "presentation",
    ...wrapperProps,
    style: {
      position: state.fixed ? "fixed" : "absolute",
      top: 0,
      left: 0,
      ...(wrapperProps == null ? void 0 : wrapperProps.style)
    },
    ref: popoverRef,
    children: element
  }), [state.fixed, popoverRef, wrapperProps]);
  props = useWrapElement(props, element => /*#__PURE__*/jsx(PopoverContext.Provider, {
    value: state,
    children: element
  }), [state]);
  props = { ...props,
    style: {
      position: "relative",
      ...props.style
    }
  };
  props = useDialog({
    state,
    modal,
    preserveTabOrder,
    portal,
    autoFocusOnShow: canAutoFocusOnShow && autoFocusOnShow,
    ...props,
    portalRef
  });
  return props;
});
/**
 * A component that renders a popover element.
 * @see https://ariakit.org/components/popover
 * @example
 * ```jsx
 * const popover = usePopoverState();
 * <PopoverDisclosure state={popover}>Disclosure</PopoverDisclosure>
 * <Popover state={popover}>Popover</Popover>
 * ```
 */

const Popover = createComponent(props => {
  const htmlProps = usePopover(props);
  return createElement("div", htmlProps);
});

if (process.env.NODE_ENV !== "production") {
  Popover.displayName = "Popover";
}

export { Popover, usePopover };
