import { useRef, useState, useEffect, useContext, useCallback, createContext } from 'react';
import { contains } from 'ariakit-utils/dom';
import { addGlobalEventListener } from 'ariakit-utils/events';
import { hasFocusWithin } from 'ariakit-utils/focus';
import { usePortalRef, useBooleanEvent, useSafeLayoutEffect, useWrapElement, useForkRef, useLiveRef, useEvent } from 'ariakit-utils/hooks';
import { chain } from 'ariakit-utils/misc';
import { createHook, createComponent, createElement } from 'ariakit-utils/system';
import { usePopover } from '../popover/popover.js';
import { jsx } from 'react/jsx-runtime';

function getEventPoint(event) {
  return [event.clientX, event.clientY];
} // Based on https://github.com/metafloor/pointinpoly

function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let inside = false;
  const length = polygon.length;

  for (let l = length, i = 0, j = l - 1; i < l; j = i++) {
    const [xi, yi] = polygon[i];
    const [xj, yj] = polygon[j];
    const [, vy] = polygon[j === 0 ? l - 1 : j - 1] || [0, 0];
    const where = (yi - yj) * (x - xi) - (xi - xj) * (y - yi);

    if (yj < yi) {
      if (y >= yj && y < yi) {
        // point on the line
        if (where === 0) return true;

        if (where > 0) {
          if (y === yj) {
            // ray intersects vertex
            if (y > vy) {
              inside = !inside;
            }
          } else {
            inside = !inside;
          }
        }
      }
    } else if (yi < yj) {
      if (y > yi && y <= yj) {
        // point on the line
        if (where === 0) return true;

        if (where < 0) {
          if (y === yj) {
            // ray intersects vertex
            if (y < vy) {
              inside = !inside;
            }
          } else {
            inside = !inside;
          }
        }
      }
    } else if (y == yi && (x >= xj && x <= xi || x >= xi && x <= xj)) {
      // point on horizontal edge
      return true;
    }
  }

  return inside;
}

function getEnterPointPlacement(enterPoint, rect) {
  const {
    top,
    right,
    bottom,
    left
  } = rect;
  const [x, y] = enterPoint;
  const placementX = x < left ? "left" : x > right ? "right" : null;
  const placementY = y < top ? "top" : y > bottom ? "bottom" : null;
  return [placementX, placementY];
}

function getElementPolygon(element, enterPoint) {
  const rect = element.getBoundingClientRect();
  const {
    top,
    right,
    bottom,
    left
  } = rect;
  const [x, y] = getEnterPointPlacement(enterPoint, rect);
  const polygon = [enterPoint];

  if (x) {
    if (y !== "top") {
      polygon.push([x === "left" ? left : right, top]);
    }

    polygon.push([x === "left" ? right : left, top]);
    polygon.push([x === "left" ? right : left, bottom]);

    if (y !== "bottom") {
      polygon.push([x === "left" ? left : right, bottom]);
    }
  } else if (y === "top") {
    polygon.push([left, top]);
    polygon.push([left, bottom]);
    polygon.push([right, bottom]);
    polygon.push([right, top]);
  } else {
    polygon.push([left, bottom]);
    polygon.push([left, top]);
    polygon.push([right, top]);
    polygon.push([right, bottom]);
  }

  return polygon;
}

function isMovingOnHovercard(target, card, anchor, nested) {
  // The hovercard element has focus so we should keep it visible.
  if (hasFocusWithin(card)) return true; // The mouse is moving on an element inside the hovercard.

  if (!target) return false;
  if (contains(card, target)) return true; // The mouse is moving on an element inside the anchor element.

  if (anchor && contains(anchor, target)) return true; // The mouse is moving on an element inside a nested hovercard.

  if (nested != null && nested.some(card => isMovingOnHovercard(target, card, anchor))) {
    return true;
  }

  return false;
} // The autoFocusOnShow state will be set to true when the hovercard disclosure
// element is clicked. We have to reset it to false when the hovercard element
// gets hidden or is unmounted.


function useAutoFocusOnShow(_ref) {
  let {
    state,
    ...props
  } = _ref;
  const mountedRef = useLiveRef(state.mounted); // Resets autoFocusOnShow

  useEffect(() => {
    if (!state.mounted) {
      state.setAutoFocusOnShow(false);
    }
  }, [state.mounted, state.setAutoFocusOnShow]); // On unmount as well.

  useEffect(() => () => {
    if (!mountedRef.current) {
      state.setAutoFocusOnShow(false);
    }
  }, [state.setAutoFocusOnShow]);
  return {
    // If the hovercard is modal, we should always autoFocus on show.
    autoFocusOnShow: !!props.modal || state.autoFocusOnShow,
    ...props
  };
} // When the hovercard element has focus, we should move focus back to the anchor
// element when the hovercard gets hidden (or unmounted).


function useAutoFocusOnHide(_ref2) {
  let {
    state,
    ...props
  } = _ref2;
  const [autoFocusOnHide, setAutoFocusOnHide] = useState(false); // Resets autoFocusOnHide

  useEffect(() => {
    if (!state.mounted) {
      setAutoFocusOnHide(false);
    }
  }, [state.mounted]);
  const onFocusProp = useEvent(props.onFocus);
  const onFocus = useCallback(event => {
    onFocusProp(event);
    if (event.defaultPrevented) return;
    setAutoFocusOnHide(true);
  }, [onFocusProp]);
  props = {
    autoFocusOnHide,
    finalFocusRef: state.anchorRef,
    ...props,
    onFocus
  };
  return props;
}

const NestedHovercardContext = /*#__PURE__*/createContext(null);
/**
 * A component hook that returns props that can be passed to `Role` or any other
 * Ariakit component to render a hovercard element, which is a popover that's
 * usually made visible by hovering the mouse cursor over an anchor element
 * (`HovercardAnchor`).
 * @see https://ariakit.org/components/hovercard
 * @example
 * ```jsx
 * const state = useHovercardState();
 * const props = useHovercard({ state });
 * <HovercardAnchor state={state}>@username</HovercardAnchor>
 * <Role {...props}>Details</Role>
 * ```
 */

const useHovercard = createHook(_ref3 => {
  let {
    state,
    modal = false,
    portal = !!modal,
    hideOnEscape = true,
    hideOnControl = false,
    hideOnHoverOutside = true,
    disablePointerEventsOnApproach = !!hideOnHoverOutside,
    ...props
  } = _ref3;
  const ref = useRef(null);
  const [nestedHovercards, setNestedHovercards] = useState([]);
  const hideTimeoutRef = useRef(0);
  const enterPointRef = useRef(null);
  const {
    portalRef,
    domReady
  } = usePortalRef(portal, props.portalRef);
  const hideOnEscapeProp = useBooleanEvent(hideOnEscape);
  const hideOnControlProp = useBooleanEvent(hideOnControl); // Hide on Escape/Control. Popover already handles this, but only when the
  // dialog, the backdrop or the disclosure elements are focused. Since the
  // hovercard, by default, does not receive focus when it's shown, we need to
  // handle this globally here.

  useEffect(() => {
    if (!state.open) return;
    return addGlobalEventListener("keydown", event => {
      if (event.defaultPrevented) return;
      const isEscape = event.key === "Escape" && hideOnEscapeProp(event);
      const isControl = event.key === "Control" && hideOnControlProp(event);

      if (isEscape || isControl) {
        state.hide();
      }
    });
  }, [state.open, hideOnEscapeProp, hideOnControlProp, state.hide]);
  const mayHideOnHoverOutside = !!hideOnHoverOutside;
  const hideOnHoverOutsideProp = useBooleanEvent(hideOnHoverOutside);
  const mayDisablePointerEvents = !!disablePointerEventsOnApproach;
  const disablePointerEventsProp = useBooleanEvent(disablePointerEventsOnApproach); // Checks whether the mouse is moving toward the hovercard. If not, hide the
  // card after a short delay (hideTimeout).

  useEffect(() => {
    if (!domReady) return;
    if (!state.mounted) return;
    if (!mayHideOnHoverOutside && !mayDisablePointerEvents) return;
    const element = ref.current;
    if (!element) return;

    const onMouseMove = event => {
      const enterPoint = enterPointRef.current;
      const target = event.target;
      const anchor = state.anchorRef.current; // Checks whether the hovercard element has focus or the mouse is moving
      // through valid hovercard elements.

      if (isMovingOnHovercard(target, element, anchor, nestedHovercards)) {
        // While the mouse is moving over the anchor element while the hover
        // card is open, keep track of the mouse position so we'll use the
        // last point before the mouse leaves the anchor element.
        enterPointRef.current = target && anchor && contains(anchor, target) ? getEventPoint(event) : null;
        window.clearTimeout(hideTimeoutRef.current);
        hideTimeoutRef.current = 0;
        return;
      } // If there's already a scheduled timeout to hide the hovercard, we do
      // nothing.


      if (hideTimeoutRef.current) return; // Enter point will be null when the user hovers over the hovercard
      // element.

      if (enterPoint) {
        const currentPoint = getEventPoint(event);
        const polygon = getElementPolygon(element, enterPoint); // If the current's event mouse position is inside the transit
        // polygon, this means that the mouse is moving toward the hover card,
        // so we disable this event. This is necessary because the mousemove
        // event may trigger focus on other elements and close the hovercard.

        if (isPointInPolygon(currentPoint, polygon)) {
          // Refreshes the enter point.
          enterPointRef.current = currentPoint;
          if (!disablePointerEventsProp(event)) return;
          event.preventDefault();
          event.stopPropagation();
          return;
        }
      }

      if (!hideOnHoverOutsideProp(event)) return; // Otherwise, hide the hovercard after a short delay (hideTimeout).

      hideTimeoutRef.current = window.setTimeout(() => {
        hideTimeoutRef.current = 0;
        state.hide();
      }, state.hideTimeout);
    };

    return addGlobalEventListener("mousemove", onMouseMove, true);
  }, [domReady, state.mounted, mayHideOnHoverOutside, mayDisablePointerEvents, state.anchorRef, nestedHovercards, disablePointerEventsProp, hideOnHoverOutsideProp, state.hide, state.hideTimeout]); // Disable mouse events while the mouse is moving toward the hovercard. This
  // is necessary because these events may trigger focus on other elements and
  // close the hovercard while the user is moving the mouse toward it.

  useEffect(() => {
    if (!domReady) return;
    if (!state.mounted) return;
    if (!mayDisablePointerEvents) return;

    const disableEvent = event => {
      const element = ref.current;
      if (!element) return;
      const enterPoint = enterPointRef.current;
      if (!enterPoint) return;
      const polygon = getElementPolygon(element, enterPoint);

      if (isPointInPolygon(getEventPoint(event), polygon)) {
        if (!disablePointerEventsProp(event)) return;
        event.preventDefault();
        event.stopPropagation();
      }
    };

    return chain( // Note: we may need to add pointer events here in the future.
    addGlobalEventListener("mouseenter", disableEvent, true), addGlobalEventListener("mouseover", disableEvent, true), addGlobalEventListener("mouseout", disableEvent, true), addGlobalEventListener("mouseleave", disableEvent, true));
  }, [domReady, state.mounted, mayDisablePointerEvents, disablePointerEventsProp]);
  const registerOnParent = useContext(NestedHovercardContext); // Register the hovercard as a nested hovercard on the parent hovercard if
  // if it's not a modal, is portal and is mounted. We don't need to register
  // non-portal hovercards because they will be captured by the contains
  // function in the isMovingOnHovercard function above. This must be a layout
  // effect so we don't lose mouse move events right after the nested
  // hovercard has been mounted (for example, a submenu that's overlapping its
  // menu button and we keep moving the mouse while the submenu is due to
  // open).

  useSafeLayoutEffect(() => {
    if (modal) return;
    if (!portal) return;
    if (!state.mounted) return;
    if (!domReady) return;
    const element = ref.current;
    if (!element) return;
    return registerOnParent == null ? void 0 : registerOnParent(element);
  }, [modal, portal, state.mounted, domReady]);
  const registerNestedHovercard = useCallback(element => {
    setNestedHovercards(prevElements => [...prevElements, element]);
    const parentUnregister = registerOnParent == null ? void 0 : registerOnParent(element);
    return () => {
      setNestedHovercards(prevElements => prevElements.filter(item => item !== element));
      parentUnregister == null ? void 0 : parentUnregister();
    };
  }, [registerOnParent]);
  props = useWrapElement(props, element => /*#__PURE__*/jsx(NestedHovercardContext.Provider, {
    value: registerNestedHovercard,
    children: element
  }), [registerNestedHovercard]);
  props = { ...props,
    ref: useForkRef(ref, props.ref)
  };
  props = useAutoFocusOnHide({
    state,
    ...props
  });
  props = useAutoFocusOnShow({
    state,
    ...props
  });
  props = usePopover({
    hideOnEscape,
    state,
    modal,
    portal,
    ...props,
    portalRef
  });
  return props;
});
/**
 * A component that renders a hovercard element, which is a popover that's
 * usually made visible by hovering the mouse cursor over an anchor element
 * (`HovercardAnchor`).
 * @see https://ariakit.org/components/hovercard
 * @example
 * ```jsx
 * const hovercard = useHovercardState();
 * <HovercardAnchor state={hovercard}>@username</HovercardAnchor>
 * <Hovercard state={hovercard}>Details</Hovercard>
 * ```
 */

const Hovercard = createComponent(props => {
  const htmlProps = useHovercard(props);
  return createElement("div", htmlProps);
});

if (process.env.NODE_ENV !== "production") {
  Hovercard.displayName = "Hovercard";
}

export { Hovercard, useHovercard };
