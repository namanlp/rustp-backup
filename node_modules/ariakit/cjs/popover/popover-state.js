'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var dom = require('@floating-ui/dom');
var hooks = require('ariakit-utils/hooks');
var reactDom = require('react-dom');
var dialog_dialogState = require('../dialog/dialog-state.js');

const middlewares = {
  arrow: dom.arrow,
  flip: dom.flip,
  offset: dom.offset,
  shift: dom.shift,
  size: dom.size
};

function createDOMRect(x, y, width, height) {
  if (x === void 0) {
    x = 0;
  }

  if (y === void 0) {
    y = 0;
  }

  if (width === void 0) {
    width = 0;
  }

  if (height === void 0) {
    height = 0;
  }

  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  } // JSDOM doesn't support DOMRect constructor.


  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect,
    toJSON: () => rect
  };
}

function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const {
    x,
    y,
    width,
    height
  } = anchorRect;
  return createDOMRect(x, y, width, height);
}

function getAnchorElement(anchorRef, getAnchorRect) {
  // https://floating-ui.com/docs/virtual-elements
  const contextElement = anchorRef.current || undefined;
  return {
    contextElement,
    getBoundingClientRect: () => {
      const anchor = anchorRef.current;
      const anchorRect = getAnchorRect(anchor);

      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }

      return anchor.getBoundingClientRect();
    }
  };
}

function isValidPlacement(flip) {
  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(flip);
}
/**
 * Provides state for the `Popover` components.
 * @example
 * ```jsx
 * const popover = usePopoverState();
 * <PopoverDisclosure state={popover}>Disclosure</PopoverDisclosure>
 * <Popover state={popover}>Popover</Popover>
 * ```
 */


function usePopoverState(_temp) {
  let {
    placement = "bottom",
    fixed = false,
    gutter,
    flip = true,
    shift = 0,
    slide = true,
    overlap = false,
    sameWidth = false,
    fitViewport = false,
    arrowPadding = 4,
    overflowPadding = 8,
    renderCallback,
    ...props
  } = _temp === void 0 ? {} : _temp;
  const dialog = dialog_dialogState.useDialogState(props);

  const defaultGetAnchorRect = anchor => (anchor == null ? void 0 : anchor.getBoundingClientRect()) || null;

  const getAnchorRect = hooks.useEvent(props.getAnchorRect || defaultGetAnchorRect);
  const anchorRef = react.useRef(null);
  const popoverRef = react.useRef(null);
  const arrowRef = react.useRef(null);
  const [currentPlacement, setCurrentPlacement] = react.useState(placement);
  const [rendered, render] = hooks.useForceUpdate();
  hooks.useSafeLayoutEffect(() => {
    var _dialog$contentElemen;

    if (!((_dialog$contentElemen = dialog.contentElement) != null && _dialog$contentElemen.isConnected)) return;
    const popover = popoverRef.current;
    if (!popover) return;
    const anchor = getAnchorElement(anchorRef, getAnchorRect);
    const arrow = arrowRef.current;
    const arrowOffset = ((arrow == null ? void 0 : arrow.clientHeight) || 0) / 2;
    const finalGutter = typeof gutter === "number" ? gutter + arrowOffset : gutter != null ? gutter : arrowOffset;
    popover.style.setProperty("--popover-overflow-padding", overflowPadding + "px");

    const defaultRenderCallback = () => {
      const update = async () => {
        if (!dialog.mounted) return;
        const middleware = [// https://floating-ui.com/docs/offset
        middlewares.offset(_ref => {
          let {
            placement
          } = _ref;
          // If there's no placement alignment (*-start or *-end), we'll
          // fallback to the crossAxis offset as it also works for
          // center-aligned placements.
          const hasAlignment = !!placement.split("-")[1];
          return {
            crossAxis: !hasAlignment ? shift : undefined,
            mainAxis: finalGutter,
            alignmentAxis: shift
          };
        })];

        if (flip !== false) {
          const fallbackPlacements = typeof flip === "string" ? flip.split(" ") : undefined;

          if (fallbackPlacements !== undefined && !fallbackPlacements.every(isValidPlacement)) {
            throw new Error("`flip` expects a spaced-delimited list of placements");
          } // https://floating-ui.com/docs/flip


          middleware.push(middlewares.flip({
            padding: overflowPadding,
            fallbackPlacements: fallbackPlacements
          }));
        }

        if (slide || overlap) {
          // https://floating-ui.com/docs/shift
          middleware.push(middlewares.shift({
            mainAxis: slide,
            crossAxis: overlap,
            padding: overflowPadding
          }));
        } // https://floating-ui.com/docs/size


        middleware.push(middlewares.size({
          padding: overflowPadding,

          apply(_ref2) {
            let {
              availableWidth,
              availableHeight,
              rects
            } = _ref2;
            const referenceWidth = Math.round(rects.reference.width);
            availableWidth = Math.floor(availableWidth);
            availableHeight = Math.floor(availableHeight);
            popover.style.setProperty("--popover-anchor-width", referenceWidth + "px");
            popover.style.setProperty("--popover-available-width", availableWidth + "px");
            popover.style.setProperty("--popover-available-height", availableHeight + "px");

            if (sameWidth) {
              popover.style.width = referenceWidth + "px";
            }

            if (fitViewport) {
              popover.style.maxWidth = availableWidth + "px";
              popover.style.maxHeight = availableHeight + "px";
            }
          }

        }));

        if (arrow) {
          // https://floating-ui.com/docs/arrow
          middleware.push(middlewares.arrow({
            element: arrow,
            padding: arrowPadding
          }));
        } // https://floating-ui.com/docs/computePosition


        const pos = await dom.computePosition(anchor, popover, {
          placement,
          strategy: fixed ? "fixed" : "absolute",
          middleware
        }); // Update the current placement state synchronously to avoid styling
        // flashes. For example, without this, a popover that has initially
        // placement set to "bottom", but gets flipped to "top" will have a
        // frame where the popover arrow is not properly rotated (PopoverArrow
        // uses the currentPlacement state).

        reactDom.flushSync(() => {
          setCurrentPlacement(pos.placement);
        });
        const x = Math.round(pos.x);
        const y = Math.round(pos.y); // https://floating-ui.com/docs/misc#subpixel-and-accelerated-positioning

        Object.assign(popover.style, {
          top: "0",
          left: "0",
          transform: "translate3d(" + x + "px, " + y + "px, 0)"
        }); // https://floating-ui.com/docs/arrow#usage

        if (arrow && pos.middlewareData.arrow) {
          const {
            x: arrowX,
            y: arrowY
          } = pos.middlewareData.arrow;
          const dir = pos.placement.split("-")[0];
          Object.assign(arrow.style, {
            left: arrowX != null ? arrowX + "px" : "",
            top: arrowY != null ? arrowY + "px" : "",
            [dir]: "100%"
          });
        }
      }; // https://floating-ui.com/docs/autoUpdate


      return dom.autoUpdate(anchor, popover, update, {
        // JSDOM doesn't support ResizeObserver
        elementResize: typeof ResizeObserver === "function"
      });
    };

    if (renderCallback) {
      return renderCallback({
        mounted: dialog.mounted,
        placement,
        fixed,
        gutter: finalGutter,
        shift,
        overlap,
        flip,
        sameWidth,
        fitViewport,
        arrowPadding,
        overflowPadding,
        popover,
        anchor,
        arrow,
        setPlacement: setCurrentPlacement,
        defaultRenderCallback
      });
    }

    return defaultRenderCallback();
  }, [rendered, dialog.contentElement, getAnchorRect, gutter, dialog.mounted, shift, overlap, flip, overflowPadding, slide, sameWidth, fitViewport, arrowPadding, placement, fixed, renderCallback]);
  const state = react.useMemo(() => ({ ...dialog,
    getAnchorRect,
    anchorRef,
    popoverRef,
    arrowRef,
    currentPlacement,
    placement,
    fixed,
    gutter,
    shift,
    flip,
    slide,
    overlap,
    sameWidth,
    fitViewport,
    arrowPadding,
    overflowPadding,
    render,
    renderCallback
  }), [dialog, getAnchorRect, currentPlacement, placement, fixed, gutter, shift, flip, slide, overlap, sameWidth, fitViewport, arrowPadding, overflowPadding, render, renderCallback]);
  return state;
}

exports.usePopoverState = usePopoverState;
