'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var hooks = require('ariakit-utils/hooks');
var popover_popoverState = require('../popover/popover-state.js');
var __utils = require('../__utils-04c64183.js');

const globalState = __utils.createGlobalTooltipState();
/**
 * Provides state for the `Tooltip` components.
 * @example
 * ```jsx
 * const tooltip = useTooltipState();
 * <TooltipAnchor state={tooltip}>Anchor</TooltipAnchor>
 * <Tooltip state={tooltip}>Tooltip</Tooltip>
 * ```
 */

function useTooltipState(_temp) {
  var _props$defaultOpen, _props$defaultOpen2, _props$open;

  let {
    placement = "top",
    timeout = 0,
    gutter = 8,
    ...props
  } = _temp === void 0 ? {} : _temp;
  const ref = react.useRef();
  const showTimeout = react.useRef();
  const hideTimeout = react.useRef();
  const clearTimeouts = react.useCallback(() => {
    window.clearTimeout(showTimeout.current);
    window.clearTimeout(hideTimeout.current);
  }, []);
  const [_open, __setOpen] = react.useState((_props$defaultOpen = props.defaultOpen) != null ? _props$defaultOpen : false);

  const _setOpen = nextOpen => {
    props.setOpen == null ? void 0 : props.setOpen(nextOpen);

    if (props.open === undefined) {
      __setOpen(nextOpen);
    }
  };

  const [open, setOpen] = hooks.useControlledState((_props$defaultOpen2 = props.defaultOpen) != null ? _props$defaultOpen2 : false, (_props$open = props.open) != null ? _props$open : _open, nextOpen => {
    clearTimeouts();

    if (nextOpen) {
      if (!timeout || globalState.activeRef) {
        // If there's no timeout or an open tooltip already, we can show this
        // immediately.
        globalState.show(ref);
      } else {
        // There may be a reference with focus whose tooltip is still not
        // open. In this case, we want to update it before it gets shown.
        globalState.show(null); // Wait for the timeout to show the tooltip.

        showTimeout.current = window.setTimeout(() => {
          globalState.show(ref);

          _setOpen(nextOpen);
        }, timeout);
        return;
      }
    } else {
      // Let's give some time so people can move from a reference to
      // another and still show tooltips immediately.
      hideTimeout.current = window.setTimeout(() => {
        globalState.hide(ref);
      }, timeout);
    }

    _setOpen(nextOpen);
  });
  const popover = popover_popoverState.usePopoverState({
    placement,
    gutter,
    ...props,
    open,
    setOpen
  });
  react.useEffect(() => {
    return globalState.subscribe(activeRef => {
      if (activeRef !== ref) {
        clearTimeouts();

        if (popover.open) {
          // Make sure there will be only one tooltip open
          popover.hide();
        }
      }
    });
  }, [clearTimeouts, popover.open, popover.hide]);
  react.useEffect(() => () => {
    clearTimeouts();
    globalState.hide(ref);
  }, [clearTimeouts]);
  const state = react.useMemo(() => ({ ...popover,
    timeout
  }), [popover, timeout]);
  return state;
}

exports.useTooltipState = useTooltipState;
