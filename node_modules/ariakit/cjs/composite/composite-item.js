'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var dom = require('ariakit-utils/dom');
var events = require('ariakit-utils/events');
var hooks = require('ariakit-utils/hooks');
var store = require('ariakit-utils/store');
var system = require('ariakit-utils/system');
var collection_collectionItem = require('../collection/collection-item.js');
var command_command = require('../command/command.js');
var __utils = require('../__utils-48b4f73e.js');
var jsxRuntime = require('react/jsx-runtime');

function isEditableElement(element) {
  if (element.isContentEditable) return true;
  if (dom.isTextField(element)) return true;
  return element.tagName === "INPUT" && !dom.isButton(element);
}

function getNextPageOffset(scrollingElement, pageUp) {
  if (pageUp === void 0) {
    pageUp = false;
  }

  const height = scrollingElement.clientHeight;
  const {
    top
  } = scrollingElement.getBoundingClientRect(); // Calculates the size of the page based on the scrolling element's height.
  // This is similar to how browsers calculate the scroll position when pressing
  // spacebar, page up, or page down.

  const pageSize = Math.max(height * 0.875, height - 40) * 1.5;
  const pageOffset = pageUp ? height - pageSize + top : pageSize + top;

  if (scrollingElement.tagName === "HTML") {
    return pageOffset + scrollingElement.scrollTop;
  }

  return pageOffset;
}

function getItemOffset(itemElement, pageUp) {
  if (pageUp === void 0) {
    pageUp = false;
  }

  const {
    top
  } = itemElement.getBoundingClientRect();

  if (pageUp) {
    // PageUp is always the inverse of PageDown. On PageDown, we consider only
    // the top offset of the element. On PageUp we need to add the height of the
    // element as well so we consider the bottom of it.
    return top + itemElement.clientHeight;
  }

  return top;
}

function findNextPageItemId(element, items, next, pageUp) {
  if (pageUp === void 0) {
    pageUp = false;
  }

  if (!items) return;
  if (!next) return;
  const scrollingElement = dom.getScrollingElement(element);
  if (!scrollingElement) return;
  const nextPageOffset = getNextPageOffset(scrollingElement, pageUp);
  let id;
  let prevDifference; // We need to loop through the next items to find the one that is closest to
  // the next page offset.

  for (let i = 0; i < items.length; i += 1) {
    const previousId = id;
    id = next(i);
    if (!id) break;
    if (id === previousId) continue;
    const item = __utils.findEnabledItemById(items, id);
    const itemElement = item == null ? void 0 : item.ref.current;
    if (!itemElement) continue;
    const itemOffset = getItemOffset(itemElement, pageUp);
    const difference = itemOffset - nextPageOffset;
    const absDifference = Math.abs(difference); // On PageUp, the element is at the next page if the difference between its
    // top offset (plus its height) and the next page offset is less than or
    // equal zero. On PageDown, the difference should be greater than or equal
    // zero.

    if (pageUp && difference <= 0 || !pageUp && difference >= 0) {
      // There may be cases when there's a lot of space between the pages, for
      // example, when there's a lot of disabled items. In this case, the first
      // item in the next page might not be the closest one. So we return the
      // previous item id if its difference is less than the current one.
      if (prevDifference !== undefined && prevDifference < absDifference) {
        id = previousId;
      }

      break;
    }

    prevDifference = absDifference;
  }

  return id;
}

function useItem(items, id) {
  return react.useMemo(() => {
    if (!id) return;
    return items == null ? void 0 : items.find(item => item.id === id);
  }, [items, id]);
}

function targetIsAnotherItem(event, items) {
  if (events.isSelfTarget(event)) return false;
  const target = event.target;
  return __utils.isItem(items, target, event.currentTarget);
}

function useRole(ref, props) {
  const [role, setRole] = react.useState(props.role);
  hooks.useSafeLayoutEffect(() => {
    const element = ref.current;
    if (!element) return;
    setRole(element.getAttribute("role") || props.role);
  }, [props.role]);
  return role;
}

function requiresAriaSelected(role) {
  return role === "option" || role === "treeitem";
}

function supportsAriaSelected(role) {
  if (role === "option") return true;
  if (role === "tab") return true;
  if (role === "treeitem") return true;
  if (role === "gridcell") return true;
  if (role === "row") return true;
  if (role === "columnheader") return true;
  if (role === "rowheader") return true;
  return false;
}
/**
 * A component hook that returns props that can be passed to `Role` or any other
 * Ariakit component to render a composite item.
 * @see https://ariakit.org/components/composite
 * @example
 * ```jsx
 * const state = useCompositeState();
 * const props = useCompositeItem({ state });
 * <Role {...props}>Item 1</Role>
 * ```
 */


const useCompositeItem = system.createHook(_ref => {
  var _state6, _state23, _state24, _state26, _state27;

  let {
    state,
    rowId: rowIdProp,
    preventScrollOnKeyDown = false,
    moveOnKeyPress = true,
    getItem: getItemProp,
    ...props
  } = _ref;
  const id = hooks.useId(props.id);
  state = store.useStore(state || __utils.CompositeContext, [react.useCallback(s => s.activeId === id, [id]), "baseRef", "items", "virtualFocus", "registerItem", "setActiveId", "orientation", "up", "next", "down", "previous", "first", "last", "move"]);
  const ref = react.useRef(null);
  const row = react.useContext(__utils.CompositeRowContext);
  const rowId = rowIdProp != null ? rowIdProp : __utils.getContextId(state, row);
  const trulyDisabled = props.disabled && !props.accessibleWhenDisabled;
  const getItem = react.useCallback(item => {
    const nextItem = { ...item,
      id,
      rowId,
      disabled: !!trulyDisabled
    };

    if (getItemProp) {
      return getItemProp(nextItem);
    }

    return nextItem;
  }, [id, rowId, trulyDisabled, getItemProp]);
  const onFocusProp = props.onFocus;
  const hasFocusedComposite = react.useRef(false);
  const onFocus = hooks.useEvent(event => {
    var _state, _state2, _state4;

    onFocusProp == null ? void 0 : onFocusProp(event);
    if (event.defaultPrevented) return;
    if (events.isPortalEvent(event)) return;
    if (!id) return; // If the target is another item, this probably means that composite items
    // are nested. This is okay when building, for example, tree or treegrid
    // elements. In this case, we just ignore the focus event on this parent
    // item.

    if ((_state = state) != null && _state.items && targetIsAnotherItem(event, state.items)) return;

    if (((_state2 = state) == null ? void 0 : _state2.activeId) !== id) {
      var _state3;

      (_state3 = state) == null ? void 0 : _state3.setActiveId(id);
    } // When using aria-activedescendant, we want to make sure that the
    // composite container receives focus, not the composite item.


    if (!((_state4 = state) != null && _state4.virtualFocus)) return; // But we'll only do this if the focused element is the composite item
    // itself

    if (!events.isSelfTarget(event)) return; // and the composite item is not a text field or contenteditable element.

    if (isEditableElement(event.currentTarget)) return;
    const composite = state.baseRef.current;
    if (!composite) return;
    hasFocusedComposite.current = true; // If the previously focused element is a composite or composite item
    // component, we'll transfer focus silently to the composite element.
    // That's because this is just a transition event, the composite element
    // was likely already focused, so we're just immediately returning focus
    // to it when navigating through the items.

    const fromComposite = event.relatedTarget === composite || __utils.isItem(state.items, event.relatedTarget);

    if (fromComposite) {
      __utils.focusSilently(composite);
    } // Otherwise, the composite element is likely not focused, so we need this
    // focus event to propagate so consumers can use the onFocus prop on
    // <Composite>.
    else {
      composite.focus();
    }
  });
  const onBlurCaptureProp = props.onBlurCapture;
  const onBlurCapture = hooks.useEvent(event => {
    var _state5;

    onBlurCaptureProp == null ? void 0 : onBlurCaptureProp(event);
    if (event.defaultPrevented) return;

    if ((_state5 = state) != null && _state5.virtualFocus && hasFocusedComposite.current) {
      // When hasFocusedComposite is true, composite has been focused right
      // after focusing on this item. This is an intermediate blur event, so
      // we ignore it.
      hasFocusedComposite.current = false;
      event.preventDefault();
      event.stopPropagation();
    }
  });
  const onKeyDownProp = props.onKeyDown;
  const preventScrollOnKeyDownProp = hooks.useBooleanEvent(preventScrollOnKeyDown);
  const moveOnKeyPressProp = hooks.useBooleanEvent(moveOnKeyPress);
  const item = useItem((_state6 = state) == null ? void 0 : _state6.items, id);
  const isGrid = !!(item != null && item.rowId);
  const onKeyDown = hooks.useEvent(event => {
    var _state7, _state8, _state9, _state10, _state11, _state12;

    onKeyDownProp == null ? void 0 : onKeyDownProp(event);
    if (event.defaultPrevented) return;
    if (!events.isSelfTarget(event)) return;
    const isVertical = ((_state7 = state) == null ? void 0 : _state7.orientation) !== "horizontal";
    const isHorizontal = ((_state8 = state) == null ? void 0 : _state8.orientation) !== "vertical";
    const keyMap = {
      ArrowUp: (isGrid || isVertical) && ((_state9 = state) == null ? void 0 : _state9.up),
      ArrowRight: (isGrid || isHorizontal) && ((_state10 = state) == null ? void 0 : _state10.next),
      ArrowDown: (isGrid || isVertical) && ((_state11 = state) == null ? void 0 : _state11.down),
      ArrowLeft: (isGrid || isHorizontal) && ((_state12 = state) == null ? void 0 : _state12.previous),
      Home: () => {
        var _state14;

        if (!isGrid || event.ctrlKey) {
          var _state13;

          return (_state13 = state) == null ? void 0 : _state13.first();
        }

        return (_state14 = state) == null ? void 0 : _state14.previous(-1);
      },
      End: () => {
        var _state16;

        if (!isGrid || event.ctrlKey) {
          var _state15;

          return (_state15 = state) == null ? void 0 : _state15.last();
        }

        return (_state16 = state) == null ? void 0 : _state16.next(-1);
      },
      PageUp: () => {
        var _state17, _state18;

        return findNextPageItemId(event.currentTarget, (_state17 = state) == null ? void 0 : _state17.items, (_state18 = state) == null ? void 0 : _state18.up, true);
      },
      PageDown: () => {
        var _state19, _state20;

        return findNextPageItemId(event.currentTarget, (_state19 = state) == null ? void 0 : _state19.items, (_state20 = state) == null ? void 0 : _state20.down);
      }
    };
    const action = keyMap[event.key];

    if (action) {
      const nextId = action();

      if (preventScrollOnKeyDownProp(event) || nextId !== undefined) {
        var _state21;

        if (!moveOnKeyPressProp(event)) return;
        event.preventDefault();
        (_state21 = state) == null ? void 0 : _state21.move(nextId);
      }
    }
  });
  const providerValue = react.useMemo(() => {
    var _state22;

    return {
      id,
      baseRef: (_state22 = state) == null ? void 0 : _state22.baseRef
    };
  }, [id, (_state23 = state) == null ? void 0 : _state23.baseRef]);
  props = hooks.useWrapElement(props, element => /*#__PURE__*/jsxRuntime.jsx(__utils.CompositeItemContext.Provider, {
    value: providerValue,
    children: element
  }), [providerValue]);
  const isActiveItem = ((_state24 = state) == null ? void 0 : _state24.activeId) === id;
  const role = useRole(ref, props);
  let ariaSelected;

  if (isActiveItem) {
    var _state25;

    if (requiresAriaSelected(role)) {
      // When the active item role _requires_ the aria-selected attribute
      // (e.g., option, treeitem), we always set it to true.
      ariaSelected = true;
    } else if ((_state25 = state) != null && _state25.virtualFocus && supportsAriaSelected(role)) {
      // Otherwise, it will be set to true when virtualFocus is set to true
      // (meaning that the focus will be managed using the
      // aria-activedescendant attribute) and the aria-selected attribute is
      // _supported_ by the active item role.
      ariaSelected = true;
    }
  }

  const shouldTabIndex = !((_state26 = state) != null && _state26.virtualFocus) && isActiveItem || // We don't want to set tabIndex="-1" when using CompositeItem as a
  // standalone component, without state props.
  !((_state27 = state) != null && _state27.items.length);
  props = {
    id,
    "aria-selected": ariaSelected,
    "data-active-item": isActiveItem ? "" : undefined,
    ...props,
    ref: hooks.useForkRef(ref, props.ref),
    tabIndex: shouldTabIndex ? props.tabIndex : -1,
    onFocus,
    onBlurCapture,
    onKeyDown
  };
  props = command_command.useCommand(props);
  props = collection_collectionItem.useCollectionItem({
    state,
    ...props,
    getItem,
    shouldRegisterItem: !!id ? props.shouldRegisterItem : false
  });
  return props;
});
/**
 * A component that renders a composite item.
 * @see https://ariakit.org/components/composite
 * @example
 * ```jsx
 * const composite = useCompositeState();
 * <Composite state={composite}>
 *   <CompositeItem>Item 1</CompositeItem>
 *   <CompositeItem>Item 2</CompositeItem>
 *   <CompositeItem>Item 3</CompositeItem>
 * </Composite>
 * ```
 */

const CompositeItem = store.createMemoComponent(props => {
  const htmlProps = useCompositeItem(props);
  return system.createElement("button", htmlProps);
});

if (process.env.NODE_ENV !== "production") {
  CompositeItem.displayName = "CompositeItem";
}

exports.CompositeItem = CompositeItem;
exports.useCompositeItem = useCompositeItem;
